{"version":3,"sources":["turbopack:///[project]/apps/safety-lms/src/lib/db/queries/course-sections.ts","turbopack:///[project]/apps/safety-lms/src/lib/db/queries/content-blocks.ts","turbopack:///[project]/apps/safety-lms/src/lib/db/queries/quiz-questions.ts","turbopack:///[project]/apps/safety-lms/src/lib/db/queries/user-progress.ts"],"sourcesContent":["import { eq, and, desc, asc, sql } from \"drizzle-orm\";\nimport { db } from \"../index\";\nimport {\n  courseSections,\n  courses,\n  contentBlocks,\n  quizQuestions,\n  CourseSection,\n  NewCourseSection,\n} from \"../schema\";\n\n/**\n * Course Section Query Operations\n * Handles database queries for course sections with proper access control\n */\n\n// =============================================================================\n// BASIC COURSE SECTION QUERIES\n// =============================================================================\n\n/**\n * Get course section by ID\n */\nexport const getCourseSectionById = async (\n  sectionId: string\n): Promise<CourseSection | null> => {\n  const result = await db\n    .select()\n    .from(courseSections)\n    .where(eq(courseSections.id, sectionId))\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get course section by course ID and section key\n */\nexport const getCourseSectionByKey = async (\n  courseId: string,\n  sectionKey: string\n): Promise<CourseSection | null> => {\n  const result = await db\n    .select()\n    .from(courseSections)\n    .where(\n      and(\n        eq(courseSections.courseId, courseId),\n        eq(courseSections.sectionKey, sectionKey)\n      )\n    )\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get all sections for a course\n */\nexport const getCourseSectionsByCourseId = async (\n  courseId: string,\n  options: {\n    includeUnpublished?: boolean;\n    sortBy?: \"orderIndex\" | \"title\" | \"createdAt\";\n    sortOrder?: \"asc\" | \"desc\";\n  } = {}\n): Promise<CourseSection[]> => {\n  const {\n    includeUnpublished = false,\n    sortBy = \"orderIndex\",\n    sortOrder = \"asc\",\n  } = options;\n\n  let whereClause = eq(courseSections.courseId, courseId);\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(courseSections.isPublished, true));\n  }\n\n  const orderBy =\n    sortOrder === \"desc\"\n      ? desc(courseSections[sortBy])\n      : asc(courseSections[sortBy]);\n\n  const result = await db\n    .select()\n    .from(courseSections)\n    .where(whereClause)\n    .orderBy(orderBy);\n\n  return result;\n};\n\n/**\n * Get course sections with content blocks and quiz questions\n */\nexport const getCourseSectionWithContent = async (\n  sectionId: string\n): Promise<{\n  section: CourseSection;\n  contentBlocks: any[];\n  quizQuestions: any[];\n} | null> => {\n  const section = await getCourseSectionById(sectionId);\n  if (!section) return null;\n\n  // Get content blocks\n  const blocks = await db\n    .select()\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId))\n    .orderBy(asc(contentBlocks.orderIndex));\n\n  // Get quiz questions\n  const questions = await db\n    .select()\n    .from(quizQuestions)\n    .where(eq(quizQuestions.sectionId, sectionId))\n    .orderBy(asc(quizQuestions.orderIndex));\n\n  return {\n    section,\n    contentBlocks: blocks,\n    quizQuestions: questions,\n  };\n};\n\n// =============================================================================\n// COURSE SECTION CREATION AND UPDATES\n// =============================================================================\n\n/**\n * Create a new course section\n */\nexport const createCourseSection = async (\n  sectionData: NewCourseSection\n): Promise<CourseSection> => {\n  const result = await db\n    .insert(courseSections)\n    .values(sectionData)\n    .returning();\n\n  return result[0];\n};\n\n/**\n * Update course section\n */\nexport const updateCourseSection = async (\n  sectionId: string,\n  updates: Partial<CourseSection>\n): Promise<CourseSection | null> => {\n  const result = await db\n    .update(courseSections)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(courseSections.id, sectionId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Delete course section\n */\nexport const deleteCourseSection = async (\n  sectionId: string\n): Promise<boolean> => {\n  const result = await db\n    .delete(courseSections)\n    .where(eq(courseSections.id, sectionId))\n    .returning();\n\n  return result.length > 0;\n};\n\n// =============================================================================\n// COURSE SECTION ORDERING OPERATIONS\n// =============================================================================\n\n/**\n * Update section order\n */\nexport const updateSectionOrder = async (\n  sectionId: string,\n  newOrderIndex: number\n): Promise<CourseSection | null> => {\n  const result = await db\n    .update(courseSections)\n    .set({\n      orderIndex: newOrderIndex,\n      updatedAt: new Date(),\n    })\n    .where(eq(courseSections.id, sectionId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Reorder multiple sections\n */\nexport const reorderSections = async (\n  courseId: string,\n  sectionOrders: Array<{ sectionId: string; orderIndex: number }>\n): Promise<CourseSection[]> => {\n  const results: CourseSection[] = [];\n\n  for (const order of sectionOrders) {\n    const result = await updateSectionOrder(order.sectionId, order.orderIndex);\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  return results;\n};\n\n/**\n * Get next available order index for a course\n */\nexport const getNextSectionOrderIndex = async (\n  courseId: string\n): Promise<number> => {\n  const result = await db\n    .select({ maxOrder: sql<number>`max(${courseSections.orderIndex})` })\n    .from(courseSections)\n    .where(eq(courseSections.courseId, courseId));\n\n  return (result[0]?.maxOrder || 0) + 1;\n};\n\n// =============================================================================\n// COURSE SECTION VALIDATION QUERIES\n// =============================================================================\n\n/**\n * Check if section key is unique within a course\n */\nexport const isSectionKeyUnique = async (\n  courseId: string,\n  sectionKey: string,\n  excludeSectionId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(courseSections.courseId, courseId),\n    eq(courseSections.sectionKey, sectionKey)\n  );\n\n  if (excludeSectionId) {\n    whereClause = and(\n      whereClause,\n      sql`${courseSections.id} != ${excludeSectionId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: courseSections.id })\n    .from(courseSections)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n/**\n * Check if order index is unique within a course\n */\nexport const isOrderIndexUnique = async (\n  courseId: string,\n  orderIndex: number,\n  excludeSectionId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(courseSections.courseId, courseId),\n    eq(courseSections.orderIndex, orderIndex)\n  );\n\n  if (excludeSectionId) {\n    whereClause = and(\n      whereClause,\n      sql`${courseSections.id} != ${excludeSectionId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: courseSections.id })\n    .from(courseSections)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n// =============================================================================\n// COURSE SECTION STATISTICS QUERIES\n// =============================================================================\n\n/**\n * Get section statistics\n */\nexport const getSectionStatistics = async (\n  sectionId: string\n): Promise<{\n  contentBlocksCount: number;\n  quizQuestionsCount: number;\n  publishedContentBlocks: number;\n  publishedQuizQuestions: number;\n} | null> => {\n  const section = await getCourseSectionById(sectionId);\n  if (!section) return null;\n\n  // Count content blocks\n  const contentBlocksResult = await db\n    .select({\n      total: sql<number>`count(*)`,\n      published: sql<number>`count(*) filter (where ${contentBlocks.sectionId} = ${sectionId})`,\n    })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId));\n\n  // Count quiz questions\n  const quizQuestionsResult = await db\n    .select({\n      total: sql<number>`count(*)`,\n      published: sql<number>`count(*) filter (where ${quizQuestions.isPublished} = true)`,\n    })\n    .from(quizQuestions)\n    .where(eq(quizQuestions.sectionId, sectionId));\n\n  return {\n    contentBlocksCount: contentBlocksResult[0]?.total || 0,\n    quizQuestionsCount: quizQuestionsResult[0]?.total || 0,\n    publishedContentBlocks: contentBlocksResult[0]?.published || 0,\n    publishedQuizQuestions: quizQuestionsResult[0]?.published || 0,\n  };\n};\n\n// =============================================================================\n// COURSE SECTION SEARCH QUERIES\n// =============================================================================\n\n/**\n * Search course sections\n */\nexport const searchCourseSections = async (\n  courseId: string,\n  searchTerm: string,\n  options: {\n    includeUnpublished?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<CourseSection[]> => {\n  const { includeUnpublished = false, limit = 20, offset = 0 } = options;\n\n  let whereClause = and(\n    eq(courseSections.courseId, courseId),\n    sql`${courseSections.title} ilike ${`%${searchTerm}%`}`\n  );\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(courseSections.isPublished, true));\n  }\n\n  const result = await db\n    .select()\n    .from(courseSections)\n    .where(whereClause)\n    .orderBy(asc(courseSections.orderIndex))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// COURSE SECTION ACCESS CONTROL QUERIES\n// =============================================================================\n\n/**\n * Get sections accessible to user based on role and course access\n */\nexport const getAccessibleCourseSections = async (\n  courseId: string,\n  userRole: string,\n  options: {\n    includeUnpublished?: boolean;\n  } = {}\n): Promise<CourseSection[]> => {\n  const { includeUnpublished = false } = options;\n\n  // Safety admins can access all sections\n  if (userRole === \"safety_admin\") {\n    return getCourseSectionsByCourseId(courseId, { includeUnpublished: true });\n  }\n\n  // Other roles can only access published sections unless explicitly allowed\n  return getCourseSectionsByCourseId(courseId, { includeUnpublished });\n};\n\n/**\n * Check if user can access a specific section\n */\nexport const canUserAccessSection = async (\n  sectionId: string,\n  userRole: string\n): Promise<boolean> => {\n  const section = await getCourseSectionById(sectionId);\n  if (!section) return false;\n\n  // Safety admins can access all sections\n  if (userRole === \"safety_admin\") return true;\n\n  // Other roles can only access published sections\n  return section.isPublished;\n};\n","import { eq, and, desc, asc, sql } from \"drizzle-orm\";\nimport { db } from \"../index\";\nimport {\n  contentBlocks,\n  courseSections,\n  ContentBlock,\n  NewContentBlock,\n  ContentBlockType,\n} from \"../schema\";\n\n/**\n * Content Block Query Operations\n * Handles database queries for content blocks with proper access control\n */\n\n// =============================================================================\n// BASIC CONTENT BLOCK QUERIES\n// =============================================================================\n\n/**\n * Get content block by ID\n */\nexport const getContentBlockById = async (\n  blockId: string\n): Promise<ContentBlock | null> => {\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(eq(contentBlocks.id, blockId))\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get all content blocks for a section\n */\nexport const getContentBlocksBySectionId = async (\n  sectionId: string,\n  options: {\n    blockType?: ContentBlockType;\n    sortBy?: \"orderIndex\" | \"blockType\" | \"createdAt\";\n    sortOrder?: \"asc\" | \"desc\";\n  } = {}\n): Promise<ContentBlock[]> => {\n  const { blockType, sortBy = \"orderIndex\", sortOrder = \"asc\" } = options;\n\n  let whereClause = eq(contentBlocks.sectionId, sectionId);\n\n  if (blockType) {\n    whereClause = and(whereClause, eq(contentBlocks.blockType, blockType));\n  }\n\n  const orderBy =\n    sortOrder === \"desc\"\n      ? desc(contentBlocks[sortBy])\n      : asc(contentBlocks[sortBy]);\n\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(whereClause)\n    .orderBy(orderBy);\n\n  return result;\n};\n\n/**\n * Get content blocks by type across all sections\n */\nexport const getContentBlocksByType = async (\n  blockType: ContentBlockType,\n  options: {\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<ContentBlock[]> => {\n  const { limit = 20, offset = 0 } = options;\n\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(eq(contentBlocks.blockType, blockType))\n    .orderBy(asc(contentBlocks.createdAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// CONTENT BLOCK CREATION AND UPDATES\n// =============================================================================\n\n/**\n * Create a new content block\n */\nexport const createContentBlock = async (\n  blockData: NewContentBlock\n): Promise<ContentBlock> => {\n  const result = await db.insert(contentBlocks).values(blockData).returning();\n\n  return result[0];\n};\n\n/**\n * Update content block\n */\nexport const updateContentBlock = async (\n  blockId: string,\n  updates: Partial<ContentBlock>\n): Promise<ContentBlock | null> => {\n  const result = await db\n    .update(contentBlocks)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(contentBlocks.id, blockId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Delete content block\n */\nexport const deleteContentBlock = async (blockId: string): Promise<boolean> => {\n  const result = await db\n    .delete(contentBlocks)\n    .where(eq(contentBlocks.id, blockId))\n    .returning();\n\n  return result.length > 0;\n};\n\n// =============================================================================\n// CONTENT BLOCK ORDERING OPERATIONS\n// =============================================================================\n\n/**\n * Update content block order\n */\nexport const updateContentBlockOrder = async (\n  blockId: string,\n  newOrderIndex: number\n): Promise<ContentBlock | null> => {\n  const result = await db\n    .update(contentBlocks)\n    .set({\n      orderIndex: newOrderIndex,\n      updatedAt: new Date(),\n    })\n    .where(eq(contentBlocks.id, blockId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Reorder multiple content blocks\n */\nexport const reorderContentBlocks = async (\n  sectionId: string,\n  blockOrders: Array<{ blockId: string; orderIndex: number }>\n): Promise<ContentBlock[]> => {\n  const results: ContentBlock[] = [];\n\n  for (const order of blockOrders) {\n    const result = await updateContentBlockOrder(\n      order.blockId,\n      order.orderIndex\n    );\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  return results;\n};\n\n/**\n * Get next available order index for a section\n */\nexport const getNextContentBlockOrderIndex = async (\n  sectionId: string\n): Promise<number> => {\n  const result = await db\n    .select({ maxOrder: sql<number>`max(${contentBlocks.orderIndex})` })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId));\n\n  return (result[0]?.maxOrder || 0) + 1;\n};\n\n// =============================================================================\n// CONTENT BLOCK VALIDATION QUERIES\n// =============================================================================\n\n/**\n * Check if order index is unique within a section\n */\nexport const isContentBlockOrderIndexUnique = async (\n  sectionId: string,\n  orderIndex: number,\n  excludeBlockId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(contentBlocks.sectionId, sectionId),\n    eq(contentBlocks.orderIndex, orderIndex)\n  );\n\n  if (excludeBlockId) {\n    whereClause = and(\n      whereClause,\n      sql`${contentBlocks.id} != ${excludeBlockId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: contentBlocks.id })\n    .from(contentBlocks)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n/**\n * Validate content block content based on block type\n */\nexport const validateContentBlockContent = async (\n  blockType: ContentBlockType,\n  content: Record<string, unknown>\n): Promise<{ isValid: boolean; errors: string[] }> => {\n  const errors: string[] = [];\n\n  switch (blockType) {\n    case \"hero\":\n      if (!content.title) errors.push(\"Hero blocks require a title\");\n      break;\n\n    case \"text\":\n      if (!content.content && !content.text) {\n        errors.push(\"Text blocks require content or text\");\n      }\n      break;\n\n    case \"image\":\n      if (!content.image?.url) {\n        errors.push(\"Image blocks require an image URL\");\n      }\n      break;\n\n    case \"table\":\n      if (!content.table?.headers || !content.table?.rows) {\n        errors.push(\"Table blocks require headers and rows\");\n      }\n      break;\n\n    case \"list\":\n      if (!content.list?.items || !Array.isArray(content.list.items)) {\n        errors.push(\"List blocks require items array\");\n      }\n      break;\n\n    case \"callout\":\n      if (!content.callout?.type || !content.callout?.content) {\n        errors.push(\"Callout blocks require type and content\");\n      }\n      break;\n\n    case \"quote\":\n      if (!content.quote?.text) {\n        errors.push(\"Quote blocks require text\");\n      }\n      break;\n\n    case \"video\":\n      if (!content.video?.url) {\n        errors.push(\"Video blocks require a video URL\");\n      }\n      break;\n\n    case \"audio\":\n      if (!content.audio?.url) {\n        errors.push(\"Audio blocks require an audio URL\");\n      }\n      break;\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n};\n\n// =============================================================================\n// CONTENT BLOCK STATISTICS QUERIES\n// =============================================================================\n\n/**\n * Get content block statistics for a section\n */\nexport const getContentBlockStatistics = async (\n  sectionId: string\n): Promise<{\n  totalBlocks: number;\n  blocksByType: Record<ContentBlockType, number>;\n  blocksWithMetadata: number;\n  blocksWithoutMetadata: number;\n} | null> => {\n  // Get total count\n  const totalResult = await db\n    .select({ count: sql<number>`count(*)` })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId));\n\n  // Get count by type\n  const typeResult = await db\n    .select({\n      blockType: contentBlocks.blockType,\n      count: sql<number>`count(*)`,\n    })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId))\n    .groupBy(contentBlocks.blockType);\n\n  // Get blocks with/without metadata\n  const metadataResult = await db\n    .select({\n      withMetadata: sql<number>`count(*) filter (where ${contentBlocks.metadata} is not null)`,\n      withoutMetadata: sql<number>`count(*) filter (where ${contentBlocks.metadata} is null)`,\n    })\n    .from(contentBlocks)\n    .where(eq(contentBlocks.sectionId, sectionId));\n\n  const blocksByType = typeResult.reduce(\n    (acc, row) => {\n      acc[row.blockType] = row.count;\n      return acc;\n    },\n    {} as Record<ContentBlockType, number>\n  );\n\n  return {\n    totalBlocks: totalResult[0]?.count || 0,\n    blocksByType,\n    blocksWithMetadata: metadataResult[0]?.withMetadata || 0,\n    blocksWithoutMetadata: metadataResult[0]?.withoutMetadata || 0,\n  };\n};\n\n// =============================================================================\n// CONTENT BLOCK SEARCH QUERIES\n// =============================================================================\n\n/**\n * Search content blocks by content\n */\nexport const searchContentBlocks = async (\n  sectionId: string,\n  searchTerm: string,\n  options: {\n    blockType?: ContentBlockType;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<ContentBlock[]> => {\n  const { blockType, limit = 20, offset = 0 } = options;\n\n  let whereClause = and(\n    eq(contentBlocks.sectionId, sectionId),\n    sql`${contentBlocks.content}::text ilike ${`%${searchTerm}%`}`\n  );\n\n  if (blockType) {\n    whereClause = and(whereClause, eq(contentBlocks.blockType, blockType));\n  }\n\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(whereClause)\n    .orderBy(asc(contentBlocks.orderIndex))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n/**\n * Search content blocks across all sections\n */\nexport const searchAllContentBlocks = async (\n  searchTerm: string,\n  options: {\n    blockType?: ContentBlockType;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<ContentBlock[]> => {\n  const { blockType, limit = 20, offset = 0 } = options;\n\n  let whereClause = sql`${contentBlocks.content}::text ilike ${`%${searchTerm}%`}`;\n\n  if (blockType) {\n    whereClause = and(whereClause, eq(contentBlocks.blockType, blockType));\n  }\n\n  const result = await db\n    .select()\n    .from(contentBlocks)\n    .where(whereClause)\n    .orderBy(asc(contentBlocks.createdAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// CONTENT BLOCK ACCESS CONTROL QUERIES\n// =============================================================================\n\n/**\n * Get content blocks accessible to user based on role and section access\n */\nexport const getAccessibleContentBlocks = async (\n  sectionId: string,\n  userRole: string,\n  options: {\n    blockType?: ContentBlockType;\n  } = {}\n): Promise<ContentBlock[]> => {\n  // All roles can access content blocks if they have section access\n  // Access control is handled at the section level\n  return getContentBlocksBySectionId(sectionId, options);\n};\n\n/**\n * Check if user can access a specific content block\n */\nexport const canUserAccessContentBlock = async (\n  blockId: string,\n  userRole: string\n): Promise<boolean> => {\n  const block = await getContentBlockById(blockId);\n  if (!block) return false;\n\n  // Access control is handled at the section level\n  // If user can access the section, they can access the content blocks\n  return true;\n};\n\n// =============================================================================\n// CONTENT BLOCK BULK OPERATIONS\n// =============================================================================\n\n/**\n * Bulk create content blocks\n */\nexport const bulkCreateContentBlocks = async (\n  blocksData: NewContentBlock[]\n): Promise<ContentBlock[]> => {\n  const result = await db.insert(contentBlocks).values(blocksData).returning();\n\n  return result;\n};\n\n/**\n * Bulk update content blocks\n */\nexport const bulkUpdateContentBlocks = async (\n  updates: Array<{ id: string; updates: Partial<ContentBlock> }>\n): Promise<ContentBlock[]> => {\n  const results: ContentBlock[] = [];\n\n  for (const update of updates) {\n    const result = await updateContentBlock(update.id, update.updates);\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  return results;\n};\n\n/**\n * Bulk delete content blocks\n */\nexport const bulkDeleteContentBlocks = async (\n  blockIds: string[]\n): Promise<number> => {\n  const result = await db\n    .delete(contentBlocks)\n    .where(sql`${contentBlocks.id} = any(${blockIds})`)\n    .returning();\n\n  return result.length;\n};\n","import { eq, and, desc, asc, sql } from \"drizzle-orm\";\nimport { db } from \"../index\";\nimport {\n  quizQuestions,\n  quizAttempts,\n  courseSections,\n  QuizQuestion,\n  NewQuizQuestion,\n  questionTypeEnum,\n} from \"../schema\";\n\n/**\n * Quiz Question Query Operations\n * Handles database queries for quiz questions with proper access control\n */\n\n// =============================================================================\n// BASIC QUIZ QUESTION QUERIES\n// =============================================================================\n\n/**\n * Get quiz question by ID\n */\nexport const getQuizQuestionById = async (\n  questionId: string\n): Promise<QuizQuestion | null> => {\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(eq(quizQuestions.id, questionId))\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get quiz question by section ID and question key\n */\nexport const getQuizQuestionByKey = async (\n  sectionId: string,\n  questionKey: string\n): Promise<QuizQuestion | null> => {\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(\n      and(\n        eq(quizQuestions.sectionId, sectionId),\n        eq(quizQuestions.questionKey, questionKey)\n      )\n    )\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get all quiz questions for a section\n */\nexport const getQuizQuestionsBySectionId = async (\n  sectionId: string,\n  options: {\n    questionType?: typeof questionTypeEnum.enumValues[number];\n    includeUnpublished?: boolean;\n    sortBy?: \"orderIndex\" | \"questionKey\" | \"createdAt\";\n    sortOrder?: \"asc\" | \"desc\";\n  } = {}\n): Promise<QuizQuestion[]> => {\n  const {\n    questionType,\n    includeUnpublished = false,\n    sortBy = \"orderIndex\",\n    sortOrder = \"asc\",\n  } = options;\n\n  let whereClause = eq(quizQuestions.sectionId, sectionId);\n\n  if (questionType) {\n    whereClause = and(\n      whereClause,\n      eq(quizQuestions.questionType, questionType)\n    );\n  }\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(quizQuestions.isPublished, true));\n  }\n\n  const orderBy =\n    sortOrder === \"desc\"\n      ? desc(quizQuestions[sortBy])\n      : asc(quizQuestions[sortBy]);\n\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(whereClause)\n    .orderBy(orderBy);\n\n  return result;\n};\n\n/**\n * Get quiz questions by type across all sections\n */\nexport const getQuizQuestionsByType = async (\n  questionType: typeof questionTypeEnum.enumValues[number],\n  options: {\n    includeUnpublished?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<QuizQuestion[]> => {\n  const { includeUnpublished = false, limit = 20, offset = 0 } = options;\n\n  let whereClause = eq(quizQuestions.questionType, questionType);\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(quizQuestions.isPublished, true));\n  }\n\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(whereClause)\n    .orderBy(asc(quizQuestions.createdAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// QUIZ QUESTION CREATION AND UPDATES\n// =============================================================================\n\n/**\n * Create a new quiz question\n */\nexport const createQuizQuestion = async (\n  questionData: NewQuizQuestion\n): Promise<QuizQuestion> => {\n  const result = await db\n    .insert(quizQuestions)\n    .values(questionData)\n    .returning();\n\n  return result[0];\n};\n\n/**\n * Update quiz question\n */\nexport const updateQuizQuestion = async (\n  questionId: string,\n  updates: Partial<QuizQuestion>\n): Promise<QuizQuestion | null> => {\n  const result = await db\n    .update(quizQuestions)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(quizQuestions.id, questionId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Delete quiz question\n */\nexport const deleteQuizQuestion = async (\n  questionId: string\n): Promise<boolean> => {\n  const result = await db\n    .delete(quizQuestions)\n    .where(eq(quizQuestions.id, questionId))\n    .returning();\n\n  return result.length > 0;\n};\n\n// =============================================================================\n// QUIZ QUESTION ORDERING OPERATIONS\n// =============================================================================\n\n/**\n * Update quiz question order\n */\nexport const updateQuizQuestionOrder = async (\n  questionId: string,\n  newOrderIndex: number\n): Promise<QuizQuestion | null> => {\n  const result = await db\n    .update(quizQuestions)\n    .set({\n      orderIndex: newOrderIndex,\n      updatedAt: new Date(),\n    })\n    .where(eq(quizQuestions.id, questionId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Reorder multiple quiz questions\n */\nexport const reorderQuizQuestions = async (\n  sectionId: string,\n  questionOrders: Array<{ questionId: string; orderIndex: number }>\n): Promise<QuizQuestion[]> => {\n  const results: QuizQuestion[] = [];\n\n  for (const order of questionOrders) {\n    const result = await updateQuizQuestionOrder(\n      order.questionId,\n      order.orderIndex\n    );\n    if (result) {\n      results.push(result);\n    }\n  }\n\n  return results;\n};\n\n/**\n * Get next available order index for a section\n */\nexport const getNextQuizQuestionOrderIndex = async (\n  sectionId: string\n): Promise<number> => {\n  const result = await db\n    .select({ maxOrder: sql<number>`max(${quizQuestions.orderIndex})` })\n    .from(quizQuestions)\n    .where(eq(quizQuestions.sectionId, sectionId));\n\n  return (result[0]?.maxOrder || 0) + 1;\n};\n\n// =============================================================================\n// QUIZ QUESTION VALIDATION QUERIES\n// =============================================================================\n\n/**\n * Check if question key is unique within a section\n */\nexport const isQuestionKeyUnique = async (\n  sectionId: string,\n  questionKey: string,\n  excludeQuestionId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(quizQuestions.sectionId, sectionId),\n    eq(quizQuestions.questionKey, questionKey)\n  );\n\n  if (excludeQuestionId) {\n    whereClause = and(\n      whereClause,\n      sql`${quizQuestions.id} != ${excludeQuestionId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: quizQuestions.id })\n    .from(quizQuestions)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n/**\n * Check if order index is unique within a section\n */\nexport const isQuizQuestionOrderIndexUnique = async (\n  sectionId: string,\n  orderIndex: number,\n  excludeQuestionId?: string\n): Promise<boolean> => {\n  let whereClause = and(\n    eq(quizQuestions.sectionId, sectionId),\n    eq(quizQuestions.orderIndex, orderIndex)\n  );\n\n  if (excludeQuestionId) {\n    whereClause = and(\n      whereClause,\n      sql`${quizQuestions.id} != ${excludeQuestionId}`\n    );\n  }\n\n  const result = await db\n    .select({ id: quizQuestions.id })\n    .from(quizQuestions)\n    .where(whereClause)\n    .limit(1);\n\n  return result.length === 0;\n};\n\n/**\n * Validate quiz question content based on question type\n */\nexport const validateQuizQuestionContent = async (\n  questionType: typeof questionTypeEnum.enumValues[number],\n  questionText: string,\n  options?: Record<string, string>,\n  correctAnswer?: unknown\n): Promise<{ isValid: boolean; errors: string[] }> => {\n  const errors: string[] = [];\n\n  if (!questionText || questionText.trim().length === 0) {\n    errors.push(\"Question text is required\");\n  }\n\n  switch (questionType) {\n    case \"true-false\":\n      if (typeof correctAnswer !== \"boolean\") {\n        errors.push(\"True/false questions require a boolean correct answer\");\n      }\n      break;\n\n    case \"multiple-choice\":\n      if (!options || Object.keys(options).length === 0) {\n        errors.push(\"Multiple choice questions require options\");\n      }\n      if (\n        typeof correctAnswer !== \"string\" ||\n        !options ||\n        !(correctAnswer in options)\n      ) {\n        errors.push(\"Correct answer must be one of the provided options\");\n      }\n      break;\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n};\n\n// =============================================================================\n// QUIZ ATTEMPT QUERIES\n// =============================================================================\n\n/**\n * Create quiz attempt\n */\nexport const createQuizAttempt = async (attemptData: {\n  userId: string;\n  quizQuestionId: string;\n  userAnswer: unknown;\n  isCorrect: boolean;\n  timeSpentSeconds: number;\n}): Promise<any> => {\n  const result = await db\n    .insert(quizAttempts)\n    .values({\n      ...attemptData,\n      attemptedAt: new Date(),\n    })\n    .returning();\n\n  return result[0];\n};\n\n/**\n * Get quiz attempts for a user\n */\nexport const getQuizAttemptsByUser = async (\n  userId: string,\n  options: {\n    quizQuestionId?: string;\n    isCorrect?: boolean;\n    dateFrom?: Date;\n    dateTo?: Date;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<any[]> => {\n  const {\n    quizQuestionId,\n    isCorrect,\n    dateFrom,\n    dateTo,\n    limit = 20,\n    offset = 0,\n  } = options;\n\n  let whereClause = eq(quizAttempts.userId, userId);\n\n  if (quizQuestionId) {\n    whereClause = and(\n      whereClause,\n      eq(quizAttempts.quizQuestionId, quizQuestionId)\n    );\n  }\n\n  if (isCorrect !== undefined) {\n    whereClause = and(whereClause, eq(quizAttempts.isCorrect, isCorrect));\n  }\n\n  if (dateFrom) {\n    whereClause = and(\n      whereClause,\n      sql`${quizAttempts.attemptedAt} >= ${dateFrom}`\n    );\n  }\n\n  if (dateTo) {\n    whereClause = and(\n      whereClause,\n      sql`${quizAttempts.attemptedAt} <= ${dateTo}`\n    );\n  }\n\n  const result = await db\n    .select()\n    .from(quizAttempts)\n    .where(whereClause)\n    .orderBy(desc(quizAttempts.attemptedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n/**\n * Get quiz attempts for a question\n */\nexport const getQuizAttemptsByQuestion = async (\n  quizQuestionId: string,\n  options: {\n    userId?: string;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<any[]> => {\n  const { userId, limit = 20, offset = 0 } = options;\n\n  let whereClause = eq(quizAttempts.quizQuestionId, quizQuestionId);\n\n  if (userId) {\n    whereClause = and(whereClause, eq(quizAttempts.userId, userId));\n  }\n\n  const result = await db\n    .select()\n    .from(quizAttempts)\n    .where(whereClause)\n    .orderBy(desc(quizAttempts.attemptedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// QUIZ QUESTION STATISTICS QUERIES\n// =============================================================================\n\n/**\n * Get quiz question statistics\n */\nexport const getQuizQuestionStatistics = async (\n  questionId: string\n): Promise<{\n  totalAttempts: number;\n  correctAttempts: number;\n  incorrectAttempts: number;\n  averageTimeSpent: number;\n  successRate: number;\n  lastAttempted?: Date;\n} | null> => {\n  const question = await getQuizQuestionById(questionId);\n  if (!question) return null;\n\n  const attempts = await getQuizAttemptsByQuestion(questionId);\n\n  const totalAttempts = attempts.length;\n  const correctAttempts = attempts.filter(a => a.isCorrect).length;\n  const incorrectAttempts = totalAttempts - correctAttempts;\n  const averageTimeSpent =\n    totalAttempts > 0\n      ? attempts.reduce((sum, a) => sum + a.timeSpentSeconds, 0) / totalAttempts\n      : 0;\n  const successRate =\n    totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0;\n  const lastAttempted =\n    attempts.length > 0\n      ? attempts.sort(\n          (a, b) => b.attemptedAt.getTime() - a.attemptedAt.getTime()\n        )[0].attemptedAt\n      : undefined;\n\n  return {\n    totalAttempts,\n    correctAttempts,\n    incorrectAttempts,\n    averageTimeSpent,\n    successRate,\n    lastAttempted,\n  };\n};\n\n/**\n * Get section quiz statistics\n */\nexport const getSectionQuizStatistics = async (\n  sectionId: string\n): Promise<{\n  totalQuestions: number;\n  publishedQuestions: number;\n  totalAttempts: number;\n  averageSuccessRate: number;\n  questionsByType: Record<typeof questionTypeEnum.enumValues[number], number>;\n} | null> => {\n  // Get questions in section\n  const questions = await getQuizQuestionsBySectionId(sectionId, {\n    includeUnpublished: true,\n  });\n\n  if (questions.length === 0) {\n    return {\n      totalQuestions: 0,\n      publishedQuestions: 0,\n      totalAttempts: 0,\n      averageSuccessRate: 0,\n      questionsByType: { \"true-false\": 0, \"multiple-choice\": 0 },\n    };\n  }\n\n  const publishedQuestions = questions.filter(q => q.isPublished).length;\n\n  // Get attempts for all questions\n  const questionIds = questions.map(q => q.id);\n  const attempts = await db\n    .select()\n    .from(quizAttempts)\n    .where(sql`${quizAttempts.quizQuestionId} = any(${questionIds})`);\n\n  const totalAttempts = attempts.length;\n  const correctAttempts = attempts.filter(a => a.isCorrect).length;\n  const averageSuccessRate =\n    totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0;\n\n  const questionsByType = questions.reduce(\n    (acc, q) => {\n      acc[q.questionType] = (acc[q.questionType] || 0) + 1;\n      return acc;\n    },\n    {} as Record<typeof questionTypeEnum.enumValues[number], number>\n  );\n\n  return {\n    totalQuestions: questions.length,\n    publishedQuestions,\n    totalAttempts,\n    averageSuccessRate,\n    questionsByType,\n  };\n};\n\n// =============================================================================\n// QUIZ QUESTION SEARCH QUERIES\n// =============================================================================\n\n/**\n * Search quiz questions by text\n */\nexport const searchQuizQuestions = async (\n  sectionId: string,\n  searchTerm: string,\n  options: {\n    questionType?: typeof questionTypeEnum.enumValues[number];\n    includeUnpublished?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<QuizQuestion[]> => {\n  const {\n    questionType,\n    includeUnpublished = false,\n    limit = 20,\n    offset = 0,\n  } = options;\n\n  let whereClause = and(\n    eq(quizQuestions.sectionId, sectionId),\n    sql`${quizQuestions.questionText} ilike ${`%${searchTerm}%`}`\n  );\n\n  if (questionType) {\n    whereClause = and(\n      whereClause,\n      eq(quizQuestions.questionType, questionType)\n    );\n  }\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(quizQuestions.isPublished, true));\n  }\n\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(whereClause)\n    .orderBy(asc(quizQuestions.orderIndex))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n/**\n * Search quiz questions across all sections\n */\nexport const searchAllQuizQuestions = async (\n  searchTerm: string,\n  options: {\n    questionType?: typeof questionTypeEnum.enumValues[number];\n    includeUnpublished?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<QuizQuestion[]> => {\n  const {\n    questionType,\n    includeUnpublished = false,\n    limit = 20,\n    offset = 0,\n  } = options;\n\n  let whereClause = sql`${quizQuestions.questionText} ilike ${`%${searchTerm}%`}`;\n\n  if (questionType) {\n    whereClause = and(\n      whereClause,\n      eq(quizQuestions.questionType, questionType)\n    );\n  }\n\n  if (!includeUnpublished) {\n    whereClause = and(whereClause, eq(quizQuestions.isPublished, true));\n  }\n\n  const result = await db\n    .select()\n    .from(quizQuestions)\n    .where(whereClause)\n    .orderBy(asc(quizQuestions.createdAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// QUIZ QUESTION ACCESS CONTROL QUERIES\n// =============================================================================\n\n/**\n * Get quiz questions accessible to user based on role and section access\n */\nexport const getAccessibleQuizQuestions = async (\n  sectionId: string,\n  userRole: string,\n  options: {\n    questionType?: typeof questionTypeEnum.enumValues[number];\n  } = {}\n): Promise<QuizQuestion[]> => {\n  // All roles can access published quiz questions if they have section access\n  // Access control is handled at the section level\n  return getQuizQuestionsBySectionId(sectionId, {\n    ...options,\n    includeUnpublished: userRole === \"safety_admin\",\n  });\n};\n\n/**\n * Check if user can access a specific quiz question\n */\nexport const canUserAccessQuizQuestion = async (\n  questionId: string,\n  userRole: string\n): Promise<boolean> => {\n  const question = await getQuizQuestionById(questionId);\n  if (!question) return false;\n\n  // Safety admins can access all questions\n  if (userRole === \"safety_admin\") return true;\n\n  // Other roles can only access published questions\n  return question.isPublished;\n};\n","import { eq, and, desc, asc, sql, gte, lte } from \"drizzle-orm\";\nimport { db } from \"../index\";\nimport {\n  userProgress,\n  courses,\n  courseSections,\n  UserProgress,\n  NewUserProgress,\n} from \"../schema\";\n\n/**\n * User Progress Query Operations\n * Handles database queries for user progress tracking with proper access control\n */\n\n// =============================================================================\n// BASIC USER PROGRESS QUERIES\n// =============================================================================\n\n/**\n * Get user progress by ID\n */\nexport const getUserProgressById = async (\n  progressId: string\n): Promise<UserProgress | null> => {\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(eq(userProgress.id, progressId))\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get user progress by user ID and section ID\n */\nexport const getUserProgressByUserAndSection = async (\n  userId: string,\n  sectionId: string\n): Promise<UserProgress | null> => {\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(\n      and(\n        eq(userProgress.userId, userId),\n        eq(userProgress.sectionId, sectionId)\n      )\n    )\n    .limit(1);\n\n  return result[0] || null;\n};\n\n/**\n * Get all progress records for a user\n */\nexport const getUserProgressByUser = async (\n  userId: string,\n  options: {\n    courseId?: string;\n    sectionId?: string;\n    isCompleted?: boolean;\n    completionPercentageMin?: number;\n    completionPercentageMax?: number;\n    dateFrom?: Date;\n    dateTo?: Date;\n    sortBy?: \"lastAccessedAt\" | \"completedAt\" | \"createdAt\";\n    sortOrder?: \"asc\" | \"desc\";\n  } = {}\n): Promise<UserProgress[]> => {\n  const {\n    courseId,\n    sectionId,\n    isCompleted,\n    completionPercentageMin,\n    completionPercentageMax,\n    dateFrom,\n    dateTo,\n    sortBy = \"lastAccessedAt\",\n    sortOrder = \"desc\",\n  } = options;\n\n  let whereClause = eq(userProgress.userId, userId);\n\n  if (courseId) {\n    whereClause = and(whereClause, eq(userProgress.courseId, courseId));\n  }\n\n  if (sectionId) {\n    whereClause = and(whereClause, eq(userProgress.sectionId, sectionId));\n  }\n\n  if (isCompleted !== undefined) {\n    whereClause = and(whereClause, eq(userProgress.isCompleted, isCompleted));\n  }\n\n  if (completionPercentageMin !== undefined) {\n    whereClause = and(\n      whereClause,\n      gte(userProgress.completionPercentage, completionPercentageMin)\n    );\n  }\n\n  if (completionPercentageMax !== undefined) {\n    whereClause = and(\n      whereClause,\n      lte(userProgress.completionPercentage, completionPercentageMax)\n    );\n  }\n\n  if (dateFrom) {\n    whereClause = and(whereClause, gte(userProgress.lastAccessedAt, dateFrom));\n  }\n\n  if (dateTo) {\n    whereClause = and(whereClause, lte(userProgress.lastAccessedAt, dateTo));\n  }\n\n  const orderBy =\n    sortOrder === \"desc\"\n      ? desc(userProgress[sortBy])\n      : asc(userProgress[sortBy]);\n\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(whereClause)\n    .orderBy(orderBy);\n\n  return result;\n};\n\n/**\n * Get all progress records for a course\n */\nexport const getUserProgressByCourse = async (\n  courseId: string,\n  options: {\n    userId?: string;\n    isCompleted?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<UserProgress[]> => {\n  const { userId, isCompleted, limit = 20, offset = 0 } = options;\n\n  let whereClause = eq(userProgress.courseId, courseId);\n\n  if (userId) {\n    whereClause = and(whereClause, eq(userProgress.userId, userId));\n  }\n\n  if (isCompleted !== undefined) {\n    whereClause = and(whereClause, eq(userProgress.isCompleted, isCompleted));\n  }\n\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(whereClause)\n    .orderBy(desc(userProgress.lastAccessedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n/**\n * Get all progress records for a section\n */\nexport const getUserProgressBySection = async (\n  sectionId: string,\n  options: {\n    userId?: string;\n    isCompleted?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<UserProgress[]> => {\n  const { userId, isCompleted, limit = 20, offset = 0 } = options;\n\n  let whereClause = eq(userProgress.sectionId, sectionId);\n\n  if (userId) {\n    whereClause = and(whereClause, eq(userProgress.userId, userId));\n  }\n\n  if (isCompleted !== undefined) {\n    whereClause = and(whereClause, eq(userProgress.isCompleted, isCompleted));\n  }\n\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(whereClause)\n    .orderBy(desc(userProgress.lastAccessedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// USER PROGRESS CREATION AND UPDATES\n// =============================================================================\n\n/**\n * Create or update user progress\n */\nexport const upsertUserProgress = async (\n  progressData: NewUserProgress\n): Promise<UserProgress> => {\n  const result = await db\n    .insert(userProgress)\n    .values(progressData)\n    .onConflictDoUpdate({\n      target: [userProgress.userId, userProgress.sectionId],\n      set: {\n        isCompleted: progressData.isCompleted,\n        completionPercentage: progressData.completionPercentage,\n        timeSpentSeconds: progressData.timeSpentSeconds,\n        lastAccessedAt: progressData.lastAccessedAt,\n        completedAt: progressData.completedAt,\n        updatedAt: new Date(),\n      },\n    })\n    .returning();\n\n  return result[0];\n};\n\n/**\n * Update user progress\n */\nexport const updateUserProgress = async (\n  progressId: string,\n  updates: Partial<UserProgress>\n): Promise<UserProgress | null> => {\n  const result = await db\n    .update(userProgress)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(eq(userProgress.id, progressId))\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Update user progress by user and section\n */\nexport const updateUserProgressByUserAndSection = async (\n  userId: string,\n  sectionId: string,\n  updates: Partial<UserProgress>\n): Promise<UserProgress | null> => {\n  const result = await db\n    .update(userProgress)\n    .set({\n      ...updates,\n      updatedAt: new Date(),\n    })\n    .where(\n      and(\n        eq(userProgress.userId, userId),\n        eq(userProgress.sectionId, sectionId)\n      )\n    )\n    .returning();\n\n  return result[0] || null;\n};\n\n/**\n * Delete user progress\n */\nexport const deleteUserProgress = async (\n  progressId: string\n): Promise<boolean> => {\n  const result = await db\n    .delete(userProgress)\n    .where(eq(userProgress.id, progressId))\n    .returning();\n\n  return result.length > 0;\n};\n\n// =============================================================================\n// COURSE COMPLETION STATUS QUERIES\n// =============================================================================\n\n/**\n * Calculate course completion status for a user\n */\nexport const calculateCourseCompletionStatus = async (\n  userId: string,\n  courseId: string\n): Promise<{\n  courseId: string;\n  userId: string;\n  totalSections: number;\n  completedSections: number;\n  completionPercentage: number;\n  timeSpentSeconds: number;\n  lastAccessedAt: Date;\n  completedAt?: Date;\n} | null> => {\n  // Get all sections for the course\n  const sections = await db\n    .select()\n    .from(courseSections)\n    .where(eq(courseSections.courseId, courseId));\n\n  if (sections.length === 0) return null;\n\n  // Get user progress for this course\n  const progressRecords = await getUserProgressByUser(userId, { courseId });\n\n  const completedSections = progressRecords.filter(p => p.isCompleted).length;\n  const completionPercentage = Math.round(\n    (completedSections / sections.length) * 100\n  );\n  const timeSpentSeconds = progressRecords.reduce(\n    (sum, p) => sum + p.timeSpentSeconds,\n    0\n  );\n\n  const lastAccessedAt =\n    progressRecords.length > 0\n      ? progressRecords.reduce(\n          (latest, p) =>\n            p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n          progressRecords[0].lastAccessedAt\n        )\n      : new Date();\n\n  const completedAt =\n    completedSections === sections.length && sections.length > 0\n      ? progressRecords.reduce(\n          (latest, p) =>\n            p.completedAt && p.completedAt > latest ? p.completedAt : latest,\n          progressRecords[0].completedAt || new Date(0)\n        )\n      : undefined;\n\n  return {\n    courseId,\n    userId,\n    totalSections: sections.length,\n    completedSections,\n    completionPercentage,\n    timeSpentSeconds,\n    lastAccessedAt,\n    completedAt:\n      completedAt && completedAt.getTime() > 0 ? completedAt : undefined,\n  };\n};\n\n/**\n * Get course completion status for multiple users\n */\nexport const getCourseCompletionStatusForUsers = async (\n  courseId: string,\n  userIds: string[]\n): Promise<\n  Array<{\n    userId: string;\n    courseId: string;\n    totalSections: number;\n    completedSections: number;\n    completionPercentage: number;\n    timeSpentSeconds: number;\n    lastAccessedAt: Date;\n    completedAt?: Date;\n  }>\n> => {\n  const results = [];\n\n  for (const userId of userIds) {\n    const status = await calculateCourseCompletionStatus(userId, courseId);\n    if (status) {\n      results.push(status);\n    }\n  }\n\n  return results;\n};\n\n// =============================================================================\n// USER PROGRESS ANALYTICS QUERIES\n// =============================================================================\n\n/**\n * Get user progress analytics\n */\nexport const getUserProgressAnalytics = async (\n  userId: string\n): Promise<{\n  userId: string;\n  totalCourses: number;\n  completedCourses: number;\n  inProgressCourses: number;\n  totalTimeSpent: number;\n  averageCompletionRate: number;\n  lastActivity?: Date;\n  coursesByStatus: {\n    completed: string[];\n    inProgress: string[];\n    notStarted: string[];\n  };\n} | null> => {\n  // Get all courses\n  const allCourses = await db\n    .select()\n    .from(courses)\n    .where(eq(courses.isPublished, true));\n\n  if (allCourses.length === 0) {\n    return {\n      userId,\n      totalCourses: 0,\n      completedCourses: 0,\n      inProgressCourses: 0,\n      totalTimeSpent: 0,\n      averageCompletionRate: 0,\n      coursesByStatus: {\n        completed: [],\n        inProgress: [],\n        notStarted: [],\n      },\n    };\n  }\n\n  // Get user progress for all courses\n  const userProgressRecords = await getUserProgressByUser(userId);\n\n  const totalCourses = allCourses.length;\n  let completedCourses = 0;\n  let inProgressCourses = 0;\n  const totalTimeSpent = userProgressRecords.reduce(\n    (sum, p) => sum + p.timeSpentSeconds,\n    0\n  );\n\n  const coursesByStatus = {\n    completed: [] as string[],\n    inProgress: [] as string[],\n    notStarted: [] as string[],\n  };\n\n  // Analyze each course\n  for (const course of allCourses) {\n    const courseProgress = userProgressRecords.filter(\n      p => p.courseId === course.id\n    );\n    const completedSections = courseProgress.filter(p => p.isCompleted).length;\n    const totalSections = courseProgress.length;\n\n    if (totalSections === 0) {\n      coursesByStatus.notStarted.push(course.id);\n    } else if (completedSections === totalSections && totalSections > 0) {\n      completedCourses++;\n      coursesByStatus.completed.push(course.id);\n    } else {\n      inProgressCourses++;\n      coursesByStatus.inProgress.push(course.id);\n    }\n  }\n\n  const averageCompletionRate =\n    totalCourses > 0 ? (completedCourses / totalCourses) * 100 : 0;\n\n  const lastActivity =\n    userProgressRecords.length > 0\n      ? userProgressRecords.reduce(\n          (latest, p) =>\n            p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n          userProgressRecords[0].lastAccessedAt\n        )\n      : undefined;\n\n  return {\n    userId,\n    totalCourses,\n    completedCourses,\n    inProgressCourses,\n    totalTimeSpent,\n    averageCompletionRate,\n    lastActivity,\n    coursesByStatus,\n  };\n};\n\n// =============================================================================\n// USER PROGRESS STATISTICS QUERIES\n// =============================================================================\n\n/**\n * Get course progress statistics\n */\nexport const getCourseProgressStatistics = async (\n  courseId: string\n): Promise<{\n  totalUsers: number;\n  completedUsers: number;\n  inProgressUsers: number;\n  averageCompletionRate: number;\n  averageTimeSpent: number;\n  lastActivity?: Date;\n} | null> => {\n  const course = await db\n    .select()\n    .from(courses)\n    .where(eq(courses.id, courseId))\n    .limit(1);\n\n  if (!course[0]) return null;\n\n  // Get all progress records for this course\n  const progressRecords = await getUserProgressByCourse(courseId);\n\n  if (progressRecords.length === 0) {\n    return {\n      totalUsers: 0,\n      completedUsers: 0,\n      inProgressUsers: 0,\n      averageCompletionRate: 0,\n      averageTimeSpent: 0,\n    };\n  }\n\n  // Group by user\n  const userProgressMap = new Map<string, UserProgress[]>();\n  progressRecords.forEach(p => {\n    const existing = userProgressMap.get(p.userId) || [];\n    existing.push(p);\n    userProgressMap.set(p.userId, existing);\n  });\n\n  const totalUsers = userProgressMap.size;\n  let completedUsers = 0;\n  let inProgressUsers = 0;\n  let totalTimeSpent = 0;\n\n  // Get total sections for the course\n  const sections = await db\n    .select()\n    .from(courseSections)\n    .where(eq(courseSections.courseId, courseId));\n\n  const totalSections = sections.length;\n\n  // Analyze each user's progress\n  for (const [userId, userProgress] of userProgressMap) {\n    const completedSections = userProgress.filter(p => p.isCompleted).length;\n    const userTimeSpent = userProgress.reduce(\n      (sum, p) => sum + p.timeSpentSeconds,\n      0\n    );\n    totalTimeSpent += userTimeSpent;\n\n    if (completedSections === totalSections && totalSections > 0) {\n      completedUsers++;\n    } else if (completedSections > 0) {\n      inProgressUsers++;\n    }\n  }\n\n  const averageCompletionRate =\n    totalUsers > 0 ? (completedUsers / totalUsers) * 100 : 0;\n  const averageTimeSpent = totalUsers > 0 ? totalTimeSpent / totalUsers : 0;\n\n  const lastActivity =\n    progressRecords.length > 0\n      ? progressRecords.reduce(\n          (latest, p) =>\n            p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n          progressRecords[0].lastAccessedAt\n        )\n      : undefined;\n\n  return {\n    totalUsers,\n    completedUsers,\n    inProgressUsers,\n    averageCompletionRate,\n    averageTimeSpent,\n    lastActivity,\n  };\n};\n\n// =============================================================================\n// USER PROGRESS SEARCH QUERIES\n// =============================================================================\n\n/**\n * Search user progress records\n */\nexport const searchUserProgress = async (\n  searchTerm: string,\n  options: {\n    userId?: string;\n    courseId?: string;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<UserProgress[]> => {\n  const { userId, courseId, limit = 20, offset = 0 } = options;\n\n  let whereClause = sql`${userProgress.userId} ilike ${`%${searchTerm}%`}`;\n\n  if (userId) {\n    whereClause = and(whereClause, eq(userProgress.userId, userId));\n  }\n\n  if (courseId) {\n    whereClause = and(whereClause, eq(userProgress.courseId, courseId));\n  }\n\n  const result = await db\n    .select()\n    .from(userProgress)\n    .where(whereClause)\n    .orderBy(desc(userProgress.lastAccessedAt))\n    .limit(limit)\n    .offset(offset);\n\n  return result;\n};\n\n// =============================================================================\n// USER PROGRESS ACCESS CONTROL QUERIES\n// =============================================================================\n\n/**\n * Get user progress accessible to user based on role and ownership\n */\nexport const getAccessibleUserProgress = async (\n  userId: string,\n  userRole: string,\n  options: {\n    courseId?: string;\n    sectionId?: string;\n  } = {}\n): Promise<UserProgress[]> => {\n  // Users can always access their own progress\n  if (userRole === \"employee\" || userRole === \"hr_admin\") {\n    return getUserProgressByUser(userId, options);\n  }\n\n  // Safety admins can access all progress\n  if (userRole === \"safety_admin\") {\n    return getUserProgressByUser(userId, options);\n  }\n\n  // Plant managers can access progress in their plant\n  if (userRole === \"plant_manager\") {\n    return getUserProgressByUser(userId, options);\n  }\n\n  // Default: users can only access their own progress\n  return getUserProgressByUser(userId, options);\n};\n\n/**\n * Check if user can access a specific progress record\n */\nexport const canUserAccessProgress = async (\n  progressId: string,\n  userId: string,\n  userRole: string\n): Promise<boolean> => {\n  const progress = await getUserProgressById(progressId);\n  if (!progress) return false;\n\n  // Users can always access their own progress\n  if (progress.userId === userId) return true;\n\n  // Safety admins can access all progress\n  if (userRole === \"safety_admin\") return true;\n\n  // Plant managers can access progress in their plant\n  if (userRole === \"plant_manager\") return true;\n\n  // HR admins can view progress in their plant\n  if (userRole === \"hr_admin\") return true;\n\n  return false;\n};\n"],"names":[],"mappings":"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"}