{"version":3,"sources":["turbopack:///[project]/apps/safety-lms/src/lib/services/lms-content-service.ts","turbopack:///[project]/apps/safety-lms/src/lib/mappers/course-section-mappers.ts","turbopack:///[project]/apps/safety-lms/src/lib/mappers/content-block-mappers.ts","turbopack:///[project]/apps/safety-lms/src/lib/mappers/quiz-question-mappers.ts","turbopack:///[project]/apps/safety-lms/src/lib/mappers/user-progress-mappers.ts"],"sourcesContent":["import { NextRequest } from \"next/server\";\nimport { z } from \"zod\";\nimport {\n  CreateCourseSectionRequest,\n  UpdateCourseSectionRequest,\n  CourseSectionResponse,\n  CourseWithSectionsResponse,\n  SectionWithContentResponse,\n  LmsContentErrorResponse,\n} from \"@specchem/contracts\";\nimport {\n  getCourseSectionById,\n  getCourseSectionByKey,\n  getCourseSectionsByCourseId,\n  getCourseSectionWithContent,\n  createCourseSection,\n  updateCourseSection,\n  deleteCourseSection,\n  reorderSections,\n  getNextSectionOrderIndex,\n  isSectionKeyUnique,\n  isOrderIndexUnique,\n  getSectionStatistics,\n  searchCourseSections,\n  getAccessibleCourseSections,\n  canUserAccessSection,\n} from \"../db/queries/course-sections\";\nimport {\n  getContentBlocksBySectionId,\n  getContentBlocksByType,\n  createContentBlock,\n  updateContentBlock,\n  deleteContentBlock,\n  reorderContentBlocks,\n  getNextContentBlockOrderIndex,\n  isContentBlockOrderIndexUnique,\n  validateContentBlockContent,\n  getContentBlockStatistics,\n  searchContentBlocks,\n  getAccessibleContentBlocks,\n  canUserAccessContentBlock,\n} from \"../db/queries/content-blocks\";\nimport {\n  getQuizQuestionsBySectionId,\n  getQuizQuestionsByType,\n  createQuizQuestion,\n  updateQuizQuestion,\n  deleteQuizQuestion,\n  reorderQuizQuestions,\n  getNextQuizQuestionOrderIndex,\n  isQuestionKeyUnique,\n  isQuizQuestionOrderIndexUnique,\n  validateQuizQuestionContent,\n  getQuizQuestionStatistics,\n  getSectionQuizStatistics,\n  searchQuizQuestions,\n  getAccessibleQuizQuestions,\n  canUserAccessQuizQuestion,\n  createQuizAttempt,\n  getQuizAttemptsByUser,\n  getQuizAttemptsByQuestion,\n  getQuizQuestionById,\n} from \"../db/queries/quiz-questions\";\nimport {\n  getUserProgressByUser,\n  getUserProgressByUserAndSection,\n  upsertUserProgress,\n  updateUserProgress,\n  updateUserProgressByUserAndSection,\n  deleteUserProgress,\n  calculateCourseCompletionStatus,\n  getUserProgressAnalytics,\n  getCourseProgressStatistics,\n  searchUserProgress,\n  getAccessibleUserProgress,\n  canUserAccessProgress,\n} from \"../db/queries/user-progress\";\nimport {\n  mapCourseSectionToApiResponse,\n  mapCourseSectionsToApiResponses,\n  mapCreateCourseSectionRequestToDb,\n  mapUpdateCourseSectionRequestToDb,\n  mapSectionWithContentToApiResponse,\n  validateSectionAccess,\n  validateAndApplySectionOrdering,\n} from \"../mappers/course-section-mappers\";\nimport {\n  mapContentBlockToApiResponse,\n  mapContentBlocksToApiResponses,\n  mapCreateContentBlockRequestToDb,\n  mapUpdateContentBlockRequestToDb,\n  validateContentBlockAccess,\n  validateAndApplyContentBlockOrdering,\n} from \"../mappers/content-block-mappers\";\nimport {\n  mapQuizQuestionToApiResponse,\n  mapQuizQuestionsToApiResponses,\n  mapCreateQuizQuestionRequestToDb,\n  mapUpdateQuizQuestionRequestToDb,\n  validateQuizAnswer,\n  mapQuizAnswerSubmissionToAttempt,\n  mapQuizAttemptToApiResponse,\n  mapQuizAttemptsToApiResponses,\n  validateQuizQuestionAccess,\n  validateAndApplyQuizQuestionOrdering,\n} from \"../mappers/quiz-question-mappers\";\nimport {\n  mapUserProgressToApiResponse,\n  mapUserProgressToApiResponses,\n  mapUpdateUserProgressRequestToDb,\n  mapCreateUserProgressRequestToDb,\n  mapCourseCompletionStatusToApiResponse,\n  calculateCourseCompletionStatus as calculateCompletionStatus,\n  mapUserProgressToAnalytics,\n  mapProgressTrackingEventToProgressUpdate,\n  validateUserProgressAccess,\n} from \"../mappers/user-progress-mappers\";\n\n/**\n * LMS Content Service Layer\n * Handles business logic for structured course content, sections, blocks, and quizzes\n */\n\n// =============================================================================\n// COURSE SECTION SERVICES\n// =============================================================================\n\n/**\n * Get course content with sections\n */\nexport const getCourseContentService = async (\n  courseKey: string,\n  languageCode: string = \"en\",\n  includeUnpublished: boolean = false,\n  userRole: string = \"employee\"\n): Promise<CourseWithSectionsResponse | LmsContentErrorResponse> => {\n  try {\n    // Get course by key (would need to implement this query)\n    // const course = await getCourseByKey(courseKey);\n    // if (!course) {\n    //   return {\n    //     success: false,\n    //     error: {\n    //       code: \"COURSE_NOT_FOUND\",\n    //       message: \"Course not found\",\n    //       timestamp: new Date().toISOString(),\n    //     },\n    //     version: \"1.0\",\n    //   };\n    // }\n\n    // Get accessible sections\n    const sections = await getAccessibleCourseSections(courseKey, userRole, {\n      includeUnpublished,\n    });\n\n    return {\n      success: true,\n      data: {\n        course: {\n          id: courseKey, // Would be actual course ID\n          courseKey,\n          title: \"Function-Specific HazMat Training\", // Would be from course\n          description:\n            \"Handling, Packaging, and Shipping DOT-Regulated Materials\",\n          version: \"1.0\",\n          isPublished: true,\n        },\n        sections: mapCourseSectionsToApiResponses(sections),\n      },\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Get section content with blocks and quiz questions\n */\nexport const getSectionContentService = async (\n  courseKey: string,\n  sectionKey: string,\n  languageCode: string = \"en\",\n  includeUnpublished: boolean = false,\n  userRole: string = \"employee\"\n): Promise<SectionWithContentResponse | LmsContentErrorResponse> => {\n  try {\n    // Get course by key (would need to implement this query)\n    // const course = await getCourseByKey(courseKey);\n    // if (!course) {\n    //   return {\n    //     success: false,\n    //     error: {\n    //       code: \"COURSE_NOT_FOUND\",\n    //       message: \"Course not found\",\n    //       timestamp: new Date().toISOString(),\n    //     },\n    //     version: \"1.0\",\n    //   };\n    // }\n\n    // Get section by key\n    const section = await getCourseSectionByKey(courseKey, sectionKey);\n    if (!section) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateSectionAccess(section, userRole, true);\n    if (!accessResult.hasAccess) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get section with content\n    const sectionWithContent = await getCourseSectionWithContent(section.id);\n    if (!sectionWithContent) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section content not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      data: mapSectionWithContentToApiResponse(\n        sectionWithContent.section,\n        sectionWithContent.contentBlocks,\n        sectionWithContent.quizQuestions\n      ),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Create course section\n */\nexport const createCourseSectionService = async (\n  courseKey: string,\n  request: CreateCourseSectionRequest,\n  userRole: string = \"employee\"\n): Promise<CourseSectionResponse | LmsContentErrorResponse> => {\n  try {\n    // Check permissions\n    if (userRole === \"employee\") {\n      return {\n        success: false,\n        error: {\n          code: \"USER_NOT_AUTHORIZED\",\n          message: \"Insufficient permissions\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get course by key (would need to implement this query)\n    // const course = await getCourseByKey(courseKey);\n    // if (!course) {\n    //   return {\n    //     success: false,\n    //     error: {\n    //       code: \"COURSE_NOT_FOUND\",\n    //       message: \"Course not found\",\n    //       timestamp: new Date().toISOString(),\n    //     },\n    //     version: \"1.0\",\n    //   };\n    // }\n\n    // Validate section key uniqueness\n    const isKeyUnique = await isSectionKeyUnique(courseKey, request.sectionKey);\n    if (!isKeyUnique) {\n      return {\n        success: false,\n        error: {\n          code: \"VALIDATION_ERROR\",\n          message: \"Section key must be unique within the course\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get next order index if not provided\n    const orderIndex =\n      request.orderIndex ?? (await getNextSectionOrderIndex(courseKey));\n\n    // Create section\n    const sectionData = mapCreateCourseSectionRequestToDb(request, courseKey);\n    const section = await createCourseSection(sectionData);\n\n    return {\n      success: true,\n      data: mapCourseSectionToApiResponse(section),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Update course section\n */\nexport const updateCourseSectionService = async (\n  sectionId: string,\n  request: UpdateCourseSectionRequest,\n  userRole: string = \"employee\"\n): Promise<CourseSectionResponse | LmsContentErrorResponse> => {\n  try {\n    // Get existing section\n    const existingSection = await getCourseSectionById(sectionId);\n    if (!existingSection) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateSectionAccess(existingSection, userRole, true);\n    if (!accessResult.hasAccess || !accessResult.permissions?.canEdit) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Validate section key uniqueness if changing\n    if (\n      request.sectionKey &&\n      request.sectionKey !== existingSection.sectionKey\n    ) {\n      const isKeyUnique = await isSectionKeyUnique(\n        existingSection.courseId,\n        request.sectionKey,\n        sectionId\n      );\n      if (!isKeyUnique) {\n        return {\n          success: false,\n          error: {\n            code: \"VALIDATION_ERROR\",\n            message: \"Section key must be unique within the course\",\n            timestamp: new Date().toISOString(),\n          },\n          version: \"1.0\",\n        };\n      }\n    }\n\n    // Update section\n    const updates = mapUpdateCourseSectionRequestToDb(request, existingSection);\n    const updatedSection = await updateCourseSection(sectionId, updates);\n\n    if (!updatedSection) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Failed to update section\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      data: mapCourseSectionToApiResponse(updatedSection),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Delete course section\n */\nexport const deleteCourseSectionService = async (\n  sectionId: string,\n  userRole: string = \"employee\"\n): Promise<\n  { success: true; message: string; version: \"1.0\" } | LmsContentErrorResponse\n> => {\n  try {\n    // Get existing section\n    const existingSection = await getCourseSectionById(sectionId);\n    if (!existingSection) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateSectionAccess(existingSection, userRole, true);\n    if (!accessResult.hasAccess || !accessResult.permissions?.canDelete) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Delete section\n    const deleted = await deleteCourseSection(sectionId);\n    if (!deleted) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Failed to delete section\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      message: \"Section deleted successfully\",\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n// =============================================================================\n// CONTENT BLOCK SERVICES\n// =============================================================================\n\n/**\n * Create content block\n */\nexport const createContentBlockService = async (\n  sectionId: string,\n  request: any, // CreateContentBlockRequest\n  userRole: string = \"employee\"\n): Promise<any> => {\n  try {\n    // Check permissions\n    if (userRole === \"employee\") {\n      return {\n        success: false,\n        error: {\n          code: \"USER_NOT_AUTHORIZED\",\n          message: \"Insufficient permissions\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get section\n    const section = await getCourseSectionById(sectionId);\n    if (!section) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: \"Section not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateSectionAccess(section, userRole, true);\n    if (!accessResult.hasAccess || !accessResult.permissions?.canEdit) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_SECTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Validate content\n    const validation = await validateContentBlockContent(\n      request.blockType,\n      request.content\n    );\n    if (!validation.isValid) {\n      return {\n        success: false,\n        error: {\n          code: \"VALIDATION_ERROR\",\n          message: validation.errors.join(\", \"),\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get next order index if not provided\n    const orderIndex =\n      request.orderIndex ?? (await getNextContentBlockOrderIndex(sectionId));\n\n    // Create content block\n    const blockData = mapCreateContentBlockRequestToDb(request, sectionId);\n    const block = await createContentBlock(blockData);\n\n    return {\n      success: true,\n      data: mapContentBlockToApiResponse(block),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n// =============================================================================\n// QUIZ QUESTION SERVICES\n// =============================================================================\n\n/**\n * Submit quiz answer\n */\nexport const submitQuizAnswerService = async (\n  quizQuestionId: string,\n  request: any, // SubmitQuizAnswerRequest\n  userId: string,\n  userRole: string = \"employee\"\n): Promise<any> => {\n  try {\n    // Get quiz question\n    const question = await getQuizQuestionById(quizQuestionId);\n    if (!question) {\n      return {\n        success: false,\n        error: {\n          code: \"QUIZ_QUESTION_NOT_FOUND\",\n          message: \"Quiz question not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Check access\n    const accessResult = validateQuizQuestionAccess(question, userRole, true);\n    if (!accessResult.hasAccess || !accessResult.permissions?.canSubmitAnswer) {\n      return {\n        success: false,\n        error: {\n          code: \"QUIZ_QUESTION_NOT_FOUND\",\n          message: accessResult.reason || \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Validate answer\n    const validation = validateQuizAnswer(question, request.userAnswer);\n    if (!validation.isValid) {\n      return {\n        success: false,\n        error: {\n          code: \"INVALID_QUIZ_ANSWER\",\n          message: validation.errors.join(\", \"),\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Create quiz attempt\n    const attemptData = mapQuizAnswerSubmissionToAttempt(\n      request,\n      userId,\n      validation.isCorrect\n    );\n    const attempt = await createQuizAttempt(attemptData);\n\n    return {\n      success: true,\n      data: mapQuizAttemptToApiResponse(attempt),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n// =============================================================================\n// USER PROGRESS SERVICES\n// =============================================================================\n\n/**\n * Update user progress\n */\nexport const updateUserProgressService = async (\n  userId: string,\n  request: any, // UpdateUserProgressRequest\n  userRole: string = \"employee\"\n): Promise<any> => {\n  try {\n    // Check permissions\n    if (userRole === \"employee\") {\n      return {\n        success: false,\n        error: {\n          code: \"USER_NOT_AUTHORIZED\",\n          message: \"Insufficient permissions\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Get existing progress or create new\n    const existingProgress = await getUserProgressByUserAndSection(\n      userId,\n      request.sectionId\n    );\n\n    let progress;\n    if (existingProgress) {\n      const updates = mapUpdateUserProgressRequestToDb(\n        request,\n        userId,\n        existingProgress\n      );\n      progress = await updateUserProgressByUserAndSection(\n        userId,\n        request.sectionId,\n        updates\n      );\n    } else {\n      const newProgress = mapCreateUserProgressRequestToDb(request, userId);\n      progress = await upsertUserProgress(newProgress);\n    }\n\n    if (!progress) {\n      return {\n        success: false,\n        error: {\n          code: \"PROGRESS_UPDATE_FAILED\",\n          message: \"Failed to update progress\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      data: mapUserProgressToApiResponse(progress),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n/**\n * Get course completion status\n */\nexport const getCourseCompletionStatusService = async (\n  userId: string,\n  courseId: string,\n  userRole: string = \"employee\"\n): Promise<any> => {\n  try {\n    // Check access\n    const canAccess = await canUserAccessProgress(\"\", userId, userRole);\n    if (!canAccess) {\n      return {\n        success: false,\n        error: {\n          code: \"USER_NOT_AUTHORIZED\",\n          message: \"Access denied\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    // Calculate completion status\n    const status = await calculateCourseCompletionStatus(userId, courseId);\n    if (!status) {\n      return {\n        success: false,\n        error: {\n          code: \"COURSE_NOT_FOUND\",\n          message: \"Course not found\",\n          timestamp: new Date().toISOString(),\n        },\n        version: \"1.0\",\n      };\n    }\n\n    return {\n      success: true,\n      data: mapCourseCompletionStatusToApiResponse(status),\n      version: \"1.0\",\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: \"SYSTEM_ERROR\",\n        message: \"Internal server error\",\n        timestamp: new Date().toISOString(),\n      },\n      version: \"1.0\",\n    };\n  }\n};\n\n// =============================================================================\n// LMS CONTENT SERVICE OBJECT\n// =============================================================================\n\n/**\n * Main LMS Content Service Object\n * Provides a unified interface for all LMS content operations\n */\nexport const lmsContentService = {\n  // Course Section Services\n  getCourseSections: async (options: any) => {\n    // Simple implementation for now\n    return {\n      success: true,\n      data: [],\n      pagination: {\n        page: 1,\n        limit: 20,\n        total: 0,\n        totalPages: 0,\n        hasNext: false,\n        hasPrev: false,\n      },\n    };\n  },\n\n  createCourseSection: async (data: any) => {\n    return createCourseSectionService(\"\", data);\n  },\n\n  updateCourseSection: async (id: string, data: any) => {\n    return updateCourseSectionService(id, data);\n  },\n\n  deleteCourseSection: async (id: string) => {\n    return deleteCourseSectionService(id);\n  },\n\n  // Content Block Services\n  getContentBlocks: async (options: any) => {\n    // Simple implementation for now\n    return {\n      success: true,\n      data: [],\n      pagination: {\n        page: 1,\n        limit: 20,\n        total: 0,\n        totalPages: 0,\n        hasNext: false,\n        hasPrev: false,\n      },\n    };\n  },\n\n  createContentBlock: async (data: any) => {\n    return createContentBlockService(\"\", data);\n  },\n\n  updateContentBlock: async (id: string, data: any) => {\n    // Implementation needed\n    return {\n      success: true,\n      data: {},\n    };\n  },\n\n  deleteContentBlock: async (id: string) => {\n    // Implementation needed\n    return {\n      success: true,\n      message: \"Content block deleted\",\n    };\n  },\n\n  // Quiz Question Services\n  getQuizQuestions: async (options: any) => {\n    try {\n      const { pagination, sectionId } = options;\n      \n      if (!sectionId) {\n        return {\n          success: false,\n          error: \"Section ID is required\",\n          data: [],\n          pagination: {\n            page: 1,\n            limit: 20,\n            total: 0,\n            totalPages: 0,\n            hasNext: false,\n            hasPrev: false,\n          },\n        };\n      }\n\n      // Get quiz questions for the section\n      const questions = await getQuizQuestionsBySectionId(sectionId, {\n        includeUnpublished: false, // Only published questions for regular users\n        sortBy: \"orderIndex\",\n        sortOrder: \"asc\",\n      });\n\n      // Calculate pagination\n      const total = questions.length;\n      const totalPages = Math.ceil(total / pagination.limit);\n      const offset = (pagination.page - 1) * pagination.limit;\n      const paginatedQuestions = questions.slice(offset, offset + pagination.limit);\n\n      return {\n        success: true,\n        data: paginatedQuestions,\n        pagination: {\n          page: pagination.page,\n          limit: pagination.limit,\n          total,\n          totalPages,\n          hasNext: pagination.page < totalPages,\n          hasPrev: pagination.page > 1,\n        },\n      };\n    } catch (error) {\n      console.error(\"Error in getQuizQuestions service:\", error);\n      return {\n        success: false,\n        error: \"Failed to fetch quiz questions\",\n        data: [],\n        pagination: {\n          page: 1,\n          limit: 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrev: false,\n        },\n      };\n    }\n  },\n\n  createQuizQuestion: async (data: any) => {\n    // Implementation needed\n    return {\n      success: true,\n      data: {},\n    };\n  },\n\n  updateQuizQuestion: async (id: string, data: any) => {\n    // Implementation needed\n    return {\n      success: true,\n      data: {},\n    };\n  },\n\n  deleteQuizQuestion: async (id: string) => {\n    // Implementation needed\n    return {\n      success: true,\n      message: \"Quiz question deleted\",\n    };\n  },\n\n  // User Progress Services\n  getUserProgress: async (options: any) => {\n    // Simple implementation for now\n    return {\n      success: true,\n      data: [],\n      pagination: {\n        page: 1,\n        limit: 20,\n        total: 0,\n        totalPages: 0,\n        hasNext: false,\n        hasPrev: false,\n      },\n    };\n  },\n\n  createUserProgress: async (data: any) => {\n    return updateUserProgressService(\"\", data);\n  },\n\n  updateUserProgress: async (id: string, data: any) => {\n    return updateUserProgressService(\"\", data);\n  },\n\n  deleteUserProgress: async (id: string) => {\n    // Implementation needed\n    return {\n      success: true,\n      message: \"User progress deleted\",\n    };\n  },\n\n  // Course Content Services\n  getCourseContent: getCourseContentService,\n  getSectionContent: getSectionContentService,\n\n  // Quiz Answer Services\n  submitQuizAnswer: submitQuizAnswerService,\n\n  // Course Completion Services\n  getCourseCompletionStatus: getCourseCompletionStatusService,\n};\n","import { CourseSection, NewCourseSection } from \"../db/schema/course-sections\";\nimport { ContentBlock } from \"../db/schema/content-blocks\";\nimport { QuizQuestion } from \"../db/schema/quiz-questions\";\nimport {\n  CourseSection as CourseSectionSchema,\n  CreateCourseSectionRequest,\n  UpdateCourseSectionRequest,\n  SectionWithContentResponse,\n} from \"@specchem/contracts\";\n\n/**\n * Course Section Data Mappers\n * Handles transformation between course section database entities and API responses\n */\n\n// =============================================================================\n// COURSE SECTION DATABASE → API RESPONSE MAPPERS\n// =============================================================================\n\n/**\n * Maps course section database entity to API response\n */\nexport const mapCourseSectionToApiResponse = (\n  section: CourseSection\n): CourseSectionSchema => ({\n  id: section.id,\n  courseId: section.courseId,\n  sectionKey: section.sectionKey,\n  title: section.title,\n  orderIndex: section.orderIndex,\n  iconName: section.iconName,\n  isPublished: section.isPublished,\n  createdAt: section.createdAt.toISOString(),\n  updatedAt: section.updatedAt.toISOString(),\n});\n\n/**\n * Maps multiple course sections to API responses\n */\nexport const mapCourseSectionsToApiResponses = (\n  sections: CourseSection[]\n): CourseSectionSchema[] => sections.map(mapCourseSectionToApiResponse);\n\n// =============================================================================\n// API REQUEST → COURSE SECTION DATABASE MAPPERS\n// =============================================================================\n\n/**\n * Maps create course section API request to database entity\n */\nexport const mapCreateCourseSectionRequestToDb = (\n  request: CreateCourseSectionRequest,\n  courseId: string\n): NewCourseSection => ({\n  courseId,\n  sectionKey: request.sectionKey,\n  title: request.title,\n  orderIndex: request.orderIndex,\n  iconName: request.iconName,\n  isPublished: request.isPublished,\n});\n\n/**\n * Maps update course section API request to database entity\n */\nexport const mapUpdateCourseSectionRequestToDb = (\n  request: UpdateCourseSectionRequest,\n  existingSection: CourseSection\n): Partial<CourseSection> => ({\n  ...existingSection,\n  sectionKey: request.sectionKey ?? existingSection.sectionKey,\n  title: request.title ?? existingSection.title,\n  orderIndex: request.orderIndex ?? existingSection.orderIndex,\n  iconName: request.iconName ?? existingSection.iconName,\n  isPublished: request.isPublished ?? existingSection.isPublished,\n  updatedAt: new Date(),\n});\n\n// =============================================================================\n// SECTION WITH CONTENT MAPPERS\n// =============================================================================\n\n/**\n * Maps section with content blocks and quiz questions to API response\n */\nexport const mapSectionWithContentToApiResponse = (\n  section: CourseSection,\n  contentBlocks: ContentBlock[],\n  quizQuestions: QuizQuestion[]\n): SectionWithContentResponse[\"data\"] => ({\n  section: mapCourseSectionToApiResponse(section),\n  contentBlocks: contentBlocks.map(mapContentBlockToApiResponse),\n  quizQuestions: quizQuestions.map(mapQuizQuestionToApiResponse),\n});\n\n// =============================================================================\n// HELPER MAPPERS FOR CONTENT BLOCKS AND QUIZ QUESTIONS\n// =============================================================================\n\n/**\n * Maps content block to API response (simplified for this context)\n */\nconst mapContentBlockToApiResponse = (block: ContentBlock) => ({\n  id: block.id,\n  sectionId: block.sectionId,\n  blockType: block.blockType,\n  orderIndex: block.orderIndex,\n  content: block.content,\n  metadata: block.metadata,\n  createdAt: block.createdAt.toISOString(),\n  updatedAt: block.updatedAt.toISOString(),\n});\n\n/**\n * Maps quiz question to API response (simplified for this context)\n */\nconst mapQuizQuestionToApiResponse = (question: QuizQuestion) => ({\n  id: question.id,\n  sectionId: question.sectionId,\n  questionKey: question.questionKey,\n  questionType: question.questionType,\n  questionText: question.questionText,\n  options: question.options,\n  correctAnswer: question.correctAnswer,\n  explanation: question.explanation,\n  orderIndex: question.orderIndex,\n  isPublished: question.isPublished,\n  createdAt: question.createdAt.toISOString(),\n  updatedAt: question.updatedAt.toISOString(),\n});\n\n// =============================================================================\n// SECTION ORDERING MAPPERS\n// =============================================================================\n\n/**\n * Section ordering result\n */\nexport interface SectionOrderingResult {\n  sections: CourseSectionSchema[];\n  reordered: boolean;\n  conflicts: Array<{\n    sectionId: string;\n    sectionKey: string;\n    conflict: string;\n  }>;\n}\n\n/**\n * Validates and applies section ordering\n */\nexport const validateAndApplySectionOrdering = (\n  sections: CourseSection[],\n  newOrder: Array<{ sectionId: string; orderIndex: number }>\n): SectionOrderingResult => {\n  const sectionMap = new Map(sections.map(s => [s.id, s]));\n  const conflicts: Array<{\n    sectionId: string;\n    sectionKey: string;\n    conflict: string;\n  }> = [];\n  const reorderedSections: CourseSection[] = [];\n\n  // Check for conflicts\n  const usedIndices = new Set<number>();\n  for (const orderItem of newOrder) {\n    const section = sectionMap.get(orderItem.sectionId);\n    if (!section) {\n      conflicts.push({\n        sectionId: orderItem.sectionId,\n        sectionKey: \"\",\n        conflict: \"Section not found\",\n      });\n      continue;\n    }\n\n    if (usedIndices.has(orderItem.orderIndex)) {\n      conflicts.push({\n        sectionId: orderItem.sectionId,\n        sectionKey: section.sectionKey,\n        conflict: \"Duplicate order index\",\n      });\n    } else {\n      usedIndices.add(orderItem.orderIndex);\n      reorderedSections.push({\n        ...section,\n        orderIndex: orderItem.orderIndex,\n        updatedAt: new Date(),\n      });\n    }\n  }\n\n  return {\n    sections: mapCourseSectionsToApiResponses(reorderedSections),\n    reordered: conflicts.length === 0,\n    conflicts,\n  };\n};\n\n// =============================================================================\n// SECTION ACCESS VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * Section access validation result\n */\nexport interface SectionAccessResult {\n  hasAccess: boolean;\n  section?: CourseSectionSchema;\n  reason?: string;\n  permissions?: {\n    canView: boolean;\n    canEdit: boolean;\n    canDelete: boolean;\n    canManageContent: boolean;\n  };\n}\n\n/**\n * Validates section access based on user role and course access\n */\nexport const validateSectionAccess = (\n  section: CourseSection,\n  userRole: string,\n  courseAccess: boolean\n): SectionAccessResult => {\n  if (!courseAccess) {\n    return {\n      hasAccess: false,\n      reason: \"User does not have access to the course\",\n    };\n  }\n\n  // Safety admins can access all sections\n  if (userRole === \"safety_admin\") {\n    return {\n      hasAccess: true,\n      section: mapCourseSectionToApiResponse(section),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n        canManageContent: true,\n      },\n    };\n  }\n\n  // Plant managers can access sections in their plant\n  if (userRole === \"plant_manager\") {\n    return {\n      hasAccess: true,\n      section: mapCourseSectionToApiResponse(section),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n        canManageContent: true,\n      },\n    };\n  }\n\n  // Safety instructors can manage sections in their plant\n  if (userRole === \"safety_instructor\") {\n    return {\n      hasAccess: true,\n      section: mapCourseSectionToApiResponse(section),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: false,\n        canManageContent: true,\n      },\n    };\n  }\n\n  // HR admins can view sections and manage content in their plant\n  if (userRole === \"hr_admin\") {\n    return {\n      hasAccess: true,\n      section: mapCourseSectionToApiResponse(section),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n        canManageContent: true,\n      },\n    };\n  }\n\n  // Employees can view published sections\n  if (userRole === \"employee\") {\n    return {\n      hasAccess: section.isPublished,\n      section: section.isPublished\n        ? mapCourseSectionToApiResponse(section)\n        : undefined,\n      permissions: {\n        canView: section.isPublished,\n        canEdit: false,\n        canDelete: false,\n        canManageContent: false,\n      },\n    };\n  }\n\n  return {\n    hasAccess: false,\n    reason: \"User does not have access to this section\",\n  };\n};\n\n// =============================================================================\n// TYPE EXPORTS\n// =============================================================================\n\nexport type { SectionOrderingResult, SectionAccessResult };\n","import { ContentBlock, NewContentBlock } from \"../db/schema/content-blocks\";\nimport { CourseSection } from \"../db/schema/course-sections\";\nimport {\n  ContentBlock as ContentBlockSchema,\n  CreateContentBlockRequest,\n  UpdateContentBlockRequest,\n  ContentBlockType,\n} from \"@specchem/contracts\";\n\n/**\n * Content Block Data Mappers\n * Handles transformation between content block database entities and API responses\n */\n\n// =============================================================================\n// CONTENT BLOCK DATABASE → API RESPONSE MAPPERS\n// =============================================================================\n\n/**\n * Maps content block database entity to API response\n */\nexport const mapContentBlockToApiResponse = (\n  block: ContentBlock\n): ContentBlockSchema => ({\n  id: block.id,\n  sectionId: block.sectionId,\n  blockType: block.blockType as ContentBlockType,\n  orderIndex: block.orderIndex,\n  content: block.content,\n  metadata: block.metadata,\n  createdAt: block.createdAt.toISOString(),\n  updatedAt: block.updatedAt.toISOString(),\n});\n\n/**\n * Maps multiple content blocks to API responses\n */\nexport const mapContentBlocksToApiResponses = (\n  blocks: ContentBlock[]\n): ContentBlockSchema[] => blocks.map(mapContentBlockToApiResponse);\n\n// =============================================================================\n// API REQUEST → CONTENT BLOCK DATABASE MAPPERS\n// =============================================================================\n\n/**\n * Maps create content block API request to database entity\n */\nexport const mapCreateContentBlockRequestToDb = (\n  request: CreateContentBlockRequest,\n  sectionId: string\n): NewContentBlock => ({\n  sectionId,\n  blockType: request.blockType,\n  orderIndex: request.orderIndex,\n  content: request.content,\n  metadata: request.metadata,\n});\n\n/**\n * Maps update content block API request to database entity\n */\nexport const mapUpdateContentBlockRequestToDb = (\n  request: UpdateContentBlockRequest,\n  existingBlock: ContentBlock\n): Partial<ContentBlock> => ({\n  ...existingBlock,\n  blockType: request.blockType ?? existingBlock.blockType,\n  orderIndex: request.orderIndex ?? existingBlock.orderIndex,\n  content: request.content ?? existingBlock.content,\n  metadata: request.metadata ?? existingBlock.metadata,\n  updatedAt: new Date(),\n});\n\n// =============================================================================\n// CONTENT BLOCK TYPE-SPECIFIC MAPPERS\n// =============================================================================\n\n/**\n * Content block type-specific content structure\n */\nexport interface ContentBlockContent {\n  title?: string;\n  subtitle?: string;\n  content?: string;\n  text?: string;\n  image?: {\n    url: string;\n    alt: string;\n    caption?: string;\n  };\n  table?: {\n    headers: string[];\n    rows: string[][];\n  };\n  list?: {\n    type: \"ordered\" | \"unordered\";\n    items: string[];\n  };\n  grid?: {\n    columns: number;\n    items: Array<{\n      title: string;\n      content: string;\n      image?: string;\n    }>;\n  };\n  callout?: {\n    type: \"info\" | \"warning\" | \"success\" | \"error\";\n    title: string;\n    content: string;\n  };\n  quote?: {\n    text: string;\n    author?: string;\n    source?: string;\n  };\n  video?: {\n    url: string;\n    title: string;\n    duration?: number;\n    thumbnail?: string;\n  };\n  audio?: {\n    url: string;\n    title: string;\n    duration?: number;\n  };\n}\n\n/**\n * Validates content block content based on block type\n */\nexport const validateContentBlockContent = (\n  blockType: ContentBlockType,\n  content: Record<string, unknown>\n): { isValid: boolean; errors: string[] } => {\n  const errors: string[] = [];\n\n  switch (blockType) {\n    case \"hero\":\n      if (!content.title) errors.push(\"Hero blocks require a title\");\n      break;\n\n    case \"text\":\n      if (!content.content && !content.text) {\n        errors.push(\"Text blocks require content or text\");\n      }\n      break;\n\n    case \"image\":\n      if (!content.image?.url) {\n        errors.push(\"Image blocks require an image URL\");\n      }\n      break;\n\n    case \"table\":\n      if (!content.table?.headers || !content.table?.rows) {\n        errors.push(\"Table blocks require headers and rows\");\n      }\n      break;\n\n    case \"list\":\n      if (!content.list?.items || !Array.isArray(content.list.items)) {\n        errors.push(\"List blocks require items array\");\n      }\n      break;\n\n    case \"callout\":\n      if (!content.callout?.type || !content.callout?.content) {\n        errors.push(\"Callout blocks require type and content\");\n      }\n      break;\n\n    case \"quote\":\n      if (!content.quote?.text) {\n        errors.push(\"Quote blocks require text\");\n      }\n      break;\n\n    case \"video\":\n      if (!content.video?.url) {\n        errors.push(\"Video blocks require a video URL\");\n      }\n      break;\n\n    case \"audio\":\n      if (!content.audio?.url) {\n        errors.push(\"Audio blocks require an audio URL\");\n      }\n      break;\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n};\n\n/**\n * Normalizes content block content based on block type\n */\nexport const normalizeContentBlockContent = (\n  blockType: ContentBlockType,\n  content: Record<string, unknown>\n): Record<string, unknown> => {\n  const normalized = { ...content };\n\n  switch (blockType) {\n    case \"hero\":\n      // Ensure hero has required fields\n      if (!normalized.title) normalized.title = \"\";\n      if (!normalized.subtitle) normalized.subtitle = \"\";\n      break;\n\n    case \"text\":\n      // Normalize text content\n      if (normalized.text && !normalized.content) {\n        normalized.content = normalized.text;\n      }\n      break;\n\n    case \"image\":\n      // Ensure image has required structure\n      if (typeof normalized.image === \"string\") {\n        normalized.image = {\n          url: normalized.image,\n          alt: \"\",\n        };\n      }\n      break;\n\n    case \"table\":\n      // Ensure table has proper structure\n      if (!normalized.table) {\n        normalized.table = {\n          headers: [],\n          rows: [],\n        };\n      }\n      break;\n\n    case \"list\":\n      // Ensure list has proper structure\n      if (!normalized.list) {\n        normalized.list = {\n          type: \"unordered\",\n          items: [],\n        };\n      }\n      break;\n\n    case \"callout\":\n      // Ensure callout has proper structure\n      if (!normalized.callout) {\n        normalized.callout = {\n          type: \"info\",\n          title: \"\",\n          content: \"\",\n        };\n      }\n      break;\n\n    case \"quote\":\n      // Ensure quote has proper structure\n      if (!normalized.quote) {\n        normalized.quote = {\n          text: \"\",\n        };\n      }\n      break;\n\n    case \"video\":\n      // Ensure video has proper structure\n      if (!normalized.video) {\n        normalized.video = {\n          url: \"\",\n          title: \"\",\n        };\n      }\n      break;\n\n    case \"audio\":\n      // Ensure audio has proper structure\n      if (!normalized.audio) {\n        normalized.audio = {\n          url: \"\",\n          title: \"\",\n        };\n      }\n      break;\n  }\n\n  return normalized;\n};\n\n// =============================================================================\n// CONTENT BLOCK ORDERING MAPPERS\n// =============================================================================\n\n/**\n * Content block ordering result\n */\nexport interface ContentBlockOrderingResult {\n  blocks: ContentBlockSchema[];\n  reordered: boolean;\n  conflicts: Array<{\n    blockId: string;\n    conflict: string;\n  }>;\n}\n\n/**\n * Validates and applies content block ordering\n */\nexport const validateAndApplyContentBlockOrdering = (\n  blocks: ContentBlock[],\n  newOrder: Array<{ blockId: string; orderIndex: number }>\n): ContentBlockOrderingResult => {\n  const blockMap = new Map(blocks.map(b => [b.id, b]));\n  const conflicts: Array<{ blockId: string; conflict: string }> = [];\n  const reorderedBlocks: ContentBlock[] = [];\n\n  // Check for conflicts\n  const usedIndices = new Set<number>();\n  for (const orderItem of newOrder) {\n    const block = blockMap.get(orderItem.blockId);\n    if (!block) {\n      conflicts.push({\n        blockId: orderItem.blockId,\n        conflict: \"Content block not found\",\n      });\n      continue;\n    }\n\n    if (usedIndices.has(orderItem.orderIndex)) {\n      conflicts.push({\n        blockId: orderItem.blockId,\n        conflict: \"Duplicate order index\",\n      });\n    } else {\n      usedIndices.add(orderItem.orderIndex);\n      reorderedBlocks.push({\n        ...block,\n        orderIndex: orderItem.orderIndex,\n        updatedAt: new Date(),\n      });\n    }\n  }\n\n  return {\n    blocks: mapContentBlocksToApiResponses(reorderedBlocks),\n    reordered: conflicts.length === 0,\n    conflicts,\n  };\n};\n\n// =============================================================================\n// CONTENT BLOCK ACCESS VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * Content block access validation result\n */\nexport interface ContentBlockAccessResult {\n  hasAccess: boolean;\n  block?: ContentBlockSchema;\n  reason?: string;\n  permissions?: {\n    canView: boolean;\n    canEdit: boolean;\n    canDelete: boolean;\n  };\n}\n\n/**\n * Validates content block access based on user role and section access\n */\nexport const validateContentBlockAccess = (\n  block: ContentBlock,\n  userRole: string,\n  sectionAccess: boolean\n): ContentBlockAccessResult => {\n  if (!sectionAccess) {\n    return {\n      hasAccess: false,\n      reason: \"User does not have access to the section\",\n    };\n  }\n\n  // Safety admins can access all content blocks\n  if (userRole === \"safety_admin\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n      },\n    };\n  }\n\n  // Plant managers can access content blocks in their plant\n  if (userRole === \"plant_manager\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n      },\n    };\n  }\n\n  // Safety instructors can manage content blocks in their plant\n  if (userRole === \"safety_instructor\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: false,\n      },\n    };\n  }\n\n  // HR admins can view content blocks in their plant\n  if (userRole === \"hr_admin\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n      },\n    };\n  }\n\n  // Employees can view content blocks (access controlled by section)\n  if (userRole === \"employee\") {\n    return {\n      hasAccess: true,\n      block: mapContentBlockToApiResponse(block),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n      },\n    };\n  }\n\n  return {\n    hasAccess: false,\n    reason: \"User does not have access to this content block\",\n  };\n};\n\n// =============================================================================\n// CONTENT BLOCK FILTERING MAPPERS\n// =============================================================================\n\n/**\n * Content block filtering criteria\n */\nexport interface ContentBlockFilterCriteria {\n  blockType?: ContentBlockType;\n  sectionId?: string;\n  hasContent?: boolean;\n  hasMetadata?: boolean;\n}\n\n/**\n * Maps filtering criteria to database query filters\n */\nexport const mapContentBlockFilterCriteriaToDbFilters = (\n  criteria: ContentBlockFilterCriteria\n): any => {\n  const where: any = {};\n\n  if (criteria.blockType) {\n    where.blockType = criteria.blockType;\n  }\n\n  if (criteria.sectionId) {\n    where.sectionId = criteria.sectionId;\n  }\n\n  if (criteria.hasContent !== undefined) {\n    if (criteria.hasContent) {\n      where.content = { not: null };\n    } else {\n      where.content = null;\n    }\n  }\n\n  if (criteria.hasMetadata !== undefined) {\n    if (criteria.hasMetadata) {\n      where.metadata = { not: null };\n    } else {\n      where.metadata = null;\n    }\n  }\n\n  return where;\n};\n\n// =============================================================================\n// TYPE EXPORTS\n// =============================================================================\n\nexport type {\n  ContentBlockContent,\n  ContentBlockOrderingResult,\n  ContentBlockAccessResult,\n  ContentBlockFilterCriteria,\n};\n","import { QuizQuestion, NewQuizQuestion } from \"../db/schema/quiz-questions\";\nimport { QuizAttempt } from \"../db/schema/quiz-attempts\";\nimport {\n  QuizQuestion as QuizQuestionSchema,\n  CreateQuizQuestionRequest,\n  UpdateQuizQuestionRequest,\n  SubmitQuizAnswerRequest,\n  QuizAttempt as QuizAttemptSchema,\n  QuestionType,\n} from \"@specchem/contracts\";\n\n/**\n * Quiz Question Data Mappers\n * Handles transformation between quiz question database entities and API responses\n */\n\n// =============================================================================\n// QUIZ QUESTION DATABASE → API RESPONSE MAPPERS\n// =============================================================================\n\n/**\n * Maps quiz question database entity to API response\n */\nexport const mapQuizQuestionToApiResponse = (\n  question: QuizQuestion\n): QuizQuestionSchema => ({\n  id: question.id,\n  sectionId: question.sectionId,\n  questionKey: question.questionKey,\n  questionType: question.questionType as QuestionType,\n  questionText: question.questionText,\n  options: question.options,\n  correctAnswer: question.correctAnswer,\n  explanation: question.explanation,\n  orderIndex: question.orderIndex,\n  isPublished: question.isPublished,\n  createdAt: question.createdAt.toISOString(),\n  updatedAt: question.updatedAt.toISOString(),\n});\n\n/**\n * Maps multiple quiz questions to API responses\n */\nexport const mapQuizQuestionsToApiResponses = (\n  questions: QuizQuestion[]\n): QuizQuestionSchema[] => questions.map(mapQuizQuestionToApiResponse);\n\n// =============================================================================\n// API REQUEST → QUIZ QUESTION DATABASE MAPPERS\n// =============================================================================\n\n/**\n * Maps create quiz question API request to database entity\n */\nexport const mapCreateQuizQuestionRequestToDb = (\n  request: CreateQuizQuestionRequest,\n  sectionId: string\n): NewQuizQuestion => ({\n  sectionId,\n  questionKey: request.questionKey,\n  questionType: request.questionType,\n  questionText: request.questionText,\n  options: request.options,\n  correctAnswer: request.correctAnswer,\n  explanation: request.explanation,\n  orderIndex: request.orderIndex,\n  isPublished: request.isPublished,\n});\n\n/**\n * Maps update quiz question API request to database entity\n */\nexport const mapUpdateQuizQuestionRequestToDb = (\n  request: UpdateQuizQuestionRequest,\n  existingQuestion: QuizQuestion\n): Partial<QuizQuestion> => ({\n  ...existingQuestion,\n  questionKey: request.questionKey ?? existingQuestion.questionKey,\n  questionType: request.questionType ?? existingQuestion.questionType,\n  questionText: request.questionText ?? existingQuestion.questionText,\n  options: request.options ?? existingQuestion.options,\n  correctAnswer: request.correctAnswer ?? existingQuestion.correctAnswer,\n  explanation: request.explanation ?? existingQuestion.explanation,\n  orderIndex: request.orderIndex ?? existingQuestion.orderIndex,\n  isPublished: request.isPublished ?? existingQuestion.isPublished,\n  updatedAt: new Date(),\n});\n\n// =============================================================================\n// QUIZ ANSWER VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * Quiz answer validation result\n */\nexport interface QuizAnswerValidationResult {\n  isValid: boolean;\n  isCorrect: boolean;\n  errors: string[];\n  explanation?: string;\n}\n\n/**\n * Validates quiz answer based on question type and correct answer\n */\nexport const validateQuizAnswer = (\n  question: QuizQuestion,\n  userAnswer: string | boolean | number\n): QuizAnswerValidationResult => {\n  const errors: string[] = [];\n\n  // Validate answer format based on question type\n  switch (question.questionType) {\n    case \"true-false\":\n      if (typeof userAnswer !== \"boolean\") {\n        errors.push(\"True/false questions require a boolean answer\");\n      }\n      break;\n\n    case \"multiple-choice\":\n      if (typeof userAnswer !== \"string\") {\n        errors.push(\"Multiple choice questions require a string answer\");\n      } else if (question.options && !(userAnswer in question.options)) {\n        errors.push(\"Answer must be one of the provided options\");\n      }\n      break;\n  }\n\n  if (errors.length > 0) {\n    return {\n      isValid: false,\n      isCorrect: false,\n      errors,\n    };\n  }\n\n  // Check if answer is correct\n  const isCorrect = userAnswer === question.correctAnswer;\n\n  return {\n    isValid: true,\n    isCorrect,\n    errors: [],\n    explanation: question.explanation,\n  };\n};\n\n/**\n * Maps quiz answer submission to quiz attempt\n */\nexport const mapQuizAnswerSubmissionToAttempt = (\n  request: SubmitQuizAnswerRequest,\n  userId: string,\n  isCorrect: boolean\n): Partial<QuizAttempt> => ({\n  userId,\n  quizQuestionId: request.quizQuestionId,\n  userAnswer: request.userAnswer,\n  isCorrect,\n  timeSpentSeconds: request.timeSpentSeconds,\n  attemptedAt: new Date(),\n});\n\n// =============================================================================\n// QUIZ ATTEMPT MAPPERS\n// =============================================================================\n\n/**\n * Maps quiz attempt database entity to API response\n */\nexport const mapQuizAttemptToApiResponse = (\n  attempt: QuizAttempt\n): QuizAttemptSchema => ({\n  id: attempt.id,\n  userId: attempt.userId,\n  quizQuestionId: attempt.quizQuestionId,\n  userAnswer: attempt.userAnswer,\n  isCorrect: attempt.isCorrect,\n  attemptedAt: attempt.attemptedAt.toISOString(),\n  timeSpentSeconds: attempt.timeSpentSeconds,\n});\n\n/**\n * Maps multiple quiz attempts to API responses\n */\nexport const mapQuizAttemptsToApiResponses = (\n  attempts: QuizAttempt[]\n): QuizAttemptSchema[] => attempts.map(mapQuizAttemptToApiResponse);\n\n// =============================================================================\n// QUIZ QUESTION ORDERING MAPPERS\n// =============================================================================\n\n/**\n * Quiz question ordering result\n */\nexport interface QuizQuestionOrderingResult {\n  questions: QuizQuestionSchema[];\n  reordered: boolean;\n  conflicts: Array<{\n    questionId: string;\n    questionKey: string;\n    conflict: string;\n  }>;\n}\n\n/**\n * Validates and applies quiz question ordering\n */\nexport const validateAndApplyQuizQuestionOrdering = (\n  questions: QuizQuestion[],\n  newOrder: Array<{ questionId: string; orderIndex: number }>\n): QuizQuestionOrderingResult => {\n  const questionMap = new Map(questions.map(q => [q.id, q]));\n  const conflicts: Array<{\n    questionId: string;\n    questionKey: string;\n    conflict: string;\n  }> = [];\n  const reorderedQuestions: QuizQuestion[] = [];\n\n  // Check for conflicts\n  const usedIndices = new Set<number>();\n  for (const orderItem of newOrder) {\n    const question = questionMap.get(orderItem.questionId);\n    if (!question) {\n      conflicts.push({\n        questionId: orderItem.questionId,\n        questionKey: \"\",\n        conflict: \"Quiz question not found\",\n      });\n      continue;\n    }\n\n    if (usedIndices.has(orderItem.orderIndex)) {\n      conflicts.push({\n        questionId: orderItem.questionId,\n        questionKey: question.questionKey,\n        conflict: \"Duplicate order index\",\n      });\n    } else {\n      usedIndices.add(orderItem.orderIndex);\n      reorderedQuestions.push({\n        ...question,\n        orderIndex: orderItem.orderIndex,\n        updatedAt: new Date(),\n      });\n    }\n  }\n\n  return {\n    questions: mapQuizQuestionsToApiResponses(reorderedQuestions),\n    reordered: conflicts.length === 0,\n    conflicts,\n  };\n};\n\n// =============================================================================\n// QUIZ QUESTION ACCESS VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * Quiz question access validation result\n */\nexport interface QuizQuestionAccessResult {\n  hasAccess: boolean;\n  question?: QuizQuestionSchema;\n  reason?: string;\n  permissions?: {\n    canView: boolean;\n    canEdit: boolean;\n    canDelete: boolean;\n    canSubmitAnswer: boolean;\n  };\n}\n\n/**\n * Validates quiz question access based on user role and section access\n */\nexport const validateQuizQuestionAccess = (\n  question: QuizQuestion,\n  userRole: string,\n  sectionAccess: boolean\n): QuizQuestionAccessResult => {\n  if (!sectionAccess) {\n    return {\n      hasAccess: false,\n      reason: \"User does not have access to the section\",\n    };\n  }\n\n  // Safety admins can access all quiz questions\n  if (userRole === \"safety_admin\") {\n    return {\n      hasAccess: true,\n      question: mapQuizQuestionToApiResponse(question),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n        canSubmitAnswer: true,\n      },\n    };\n  }\n\n  // Plant managers can access quiz questions in their plant\n  if (userRole === \"plant_manager\") {\n    return {\n      hasAccess: true,\n      question: mapQuizQuestionToApiResponse(question),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n        canSubmitAnswer: true,\n      },\n    };\n  }\n\n  // Safety instructors can manage quiz questions in their plant\n  if (userRole === \"safety_instructor\") {\n    return {\n      hasAccess: true,\n      question: mapQuizQuestionToApiResponse(question),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: false,\n        canSubmitAnswer: true,\n      },\n    };\n  }\n\n  // HR admins can view quiz questions in their plant\n  if (userRole === \"hr_admin\") {\n    return {\n      hasAccess: true,\n      question: mapQuizQuestionToApiResponse(question),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n        canSubmitAnswer: true,\n      },\n    };\n  }\n\n  // Employees can view and answer published quiz questions\n  if (userRole === \"employee\") {\n    return {\n      hasAccess: question.isPublished,\n      question: question.isPublished\n        ? mapQuizQuestionToApiResponse(question)\n        : undefined,\n      permissions: {\n        canView: question.isPublished,\n        canEdit: false,\n        canDelete: false,\n        canSubmitAnswer: question.isPublished,\n      },\n    };\n  }\n\n  return {\n    hasAccess: false,\n    reason: \"User does not have access to this quiz question\",\n  };\n};\n\n// =============================================================================\n// QUIZ STATISTICS MAPPERS\n// =============================================================================\n\n/**\n * Quiz question statistics\n */\nexport interface QuizQuestionStatistics {\n  question: QuizQuestionSchema;\n  totalAttempts: number;\n  correctAttempts: number;\n  incorrectAttempts: number;\n  averageTimeSpent: number;\n  successRate: number;\n  lastAttempted?: string;\n}\n\n/**\n * Maps quiz question to statistics response\n */\nexport const mapQuizQuestionToStatistics = (\n  question: QuizQuestion,\n  attempts: QuizAttempt[]\n): QuizQuestionStatistics => {\n  const totalAttempts = attempts.length;\n  const correctAttempts = attempts.filter(a => a.isCorrect).length;\n  const incorrectAttempts = totalAttempts - correctAttempts;\n  const averageTimeSpent =\n    totalAttempts > 0\n      ? attempts.reduce((sum, a) => sum + a.timeSpentSeconds, 0) / totalAttempts\n      : 0;\n  const successRate =\n    totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0;\n  const lastAttempted =\n    attempts.length > 0\n      ? attempts\n          .sort((a, b) => b.attemptedAt.getTime() - a.attemptedAt.getTime())[0]\n          .attemptedAt.toISOString()\n      : undefined;\n\n  return {\n    question: mapQuizQuestionToApiResponse(question),\n    totalAttempts,\n    correctAttempts,\n    incorrectAttempts,\n    averageTimeSpent,\n    successRate,\n    lastAttempted,\n  };\n};\n\n// =============================================================================\n// QUIZ QUESTION FILTERING MAPPERS\n// =============================================================================\n\n/**\n * Quiz question filtering criteria\n */\nexport interface QuizQuestionFilterCriteria {\n  questionType?: QuestionType;\n  sectionId?: string;\n  isPublished?: boolean;\n  hasOptions?: boolean;\n  hasExplanation?: boolean;\n}\n\n/**\n * Maps filtering criteria to database query filters\n */\nexport const mapQuizQuestionFilterCriteriaToDbFilters = (\n  criteria: QuizQuestionFilterCriteria\n): any => {\n  const where: any = {};\n\n  if (criteria.questionType) {\n    where.questionType = criteria.questionType;\n  }\n\n  if (criteria.sectionId) {\n    where.sectionId = criteria.sectionId;\n  }\n\n  if (criteria.isPublished !== undefined) {\n    where.isPublished = criteria.isPublished;\n  }\n\n  if (criteria.hasOptions !== undefined) {\n    if (criteria.hasOptions) {\n      where.options = { not: null };\n    } else {\n      where.options = null;\n    }\n  }\n\n  if (criteria.hasExplanation !== undefined) {\n    if (criteria.hasExplanation) {\n      where.explanation = { not: null };\n    } else {\n      where.explanation = null;\n    }\n  }\n\n  return where;\n};\n\n// =============================================================================\n// TYPE EXPORTS\n// =============================================================================\n\nexport type {\n  QuizAnswerValidationResult,\n  QuizQuestionOrderingResult,\n  QuizQuestionAccessResult,\n  QuizQuestionStatistics,\n  QuizQuestionFilterCriteria,\n};\n","import { UserProgress, NewUserProgress } from \"../db/schema/user-progress\";\nimport { CourseSection } from \"../db/schema/course-sections\";\nimport { Course } from \"../db/schema/courses\";\nimport {\n  UserProgress as UserProgressSchema,\n  UpdateUserProgressRequest,\n  CourseCompletionStatusResponse,\n} from \"@specchem/contracts\";\n\n/**\n * User Progress Data Mappers\n * Handles transformation between user progress database entities and API responses\n */\n\n// =============================================================================\n// USER PROGRESS DATABASE → API RESPONSE MAPPERS\n// =============================================================================\n\n/**\n * Maps user progress database entity to API response\n */\nexport const mapUserProgressToApiResponse = (\n  progress: UserProgress\n): UserProgressSchema => ({\n  id: progress.id,\n  userId: progress.userId,\n  courseId: progress.courseId,\n  sectionId: progress.sectionId,\n  isCompleted: progress.isCompleted,\n  completionPercentage: progress.completionPercentage,\n  timeSpentSeconds: progress.timeSpentSeconds,\n  lastAccessedAt: progress.lastAccessedAt.toISOString(),\n  completedAt: progress.completedAt?.toISOString(),\n  createdAt: progress.createdAt.toISOString(),\n  updatedAt: progress.updatedAt.toISOString(),\n});\n\n/**\n * Maps multiple user progress records to API responses\n */\nexport const mapUserProgressToApiResponses = (\n  progressRecords: UserProgress[]\n): UserProgressSchema[] => progressRecords.map(mapUserProgressToApiResponse);\n\n// =============================================================================\n// API REQUEST → USER PROGRESS DATABASE MAPPERS\n// =============================================================================\n\n/**\n * Maps update user progress API request to database entity\n */\nexport const mapUpdateUserProgressRequestToDb = (\n  request: UpdateUserProgressRequest,\n  userId: string,\n  existingProgress?: UserProgress\n): Partial<UserProgress> => {\n  const now = new Date();\n\n  return {\n    ...existingProgress,\n    userId,\n    courseId: request.courseId,\n    sectionId: request.sectionId,\n    isCompleted: request.isCompleted ?? existingProgress?.isCompleted ?? false,\n    completionPercentage:\n      request.completionPercentage ??\n      existingProgress?.completionPercentage ??\n      0,\n    timeSpentSeconds:\n      request.timeSpentSeconds ?? existingProgress?.timeSpentSeconds ?? 0,\n    lastAccessedAt: now,\n    completedAt: request.isCompleted ? now : existingProgress?.completedAt,\n    updatedAt: now,\n  };\n};\n\n/**\n * Creates new user progress record\n */\nexport const mapCreateUserProgressRequestToDb = (\n  request: UpdateUserProgressRequest,\n  userId: string\n): NewUserProgress => {\n  const now = new Date();\n\n  return {\n    userId,\n    courseId: request.courseId,\n    sectionId: request.sectionId,\n    isCompleted: request.isCompleted ?? false,\n    completionPercentage: request.completionPercentage ?? 0,\n    timeSpentSeconds: request.timeSpentSeconds ?? 0,\n    lastAccessedAt: now,\n    completedAt: request.isCompleted ? now : undefined,\n  };\n};\n\n// =============================================================================\n// COURSE COMPLETION STATUS MAPPERS\n// =============================================================================\n\n/**\n * Course completion status data\n */\nexport interface CourseCompletionStatusData {\n  courseId: string;\n  userId: string;\n  totalSections: number;\n  completedSections: number;\n  completionPercentage: number;\n  timeSpentSeconds: number;\n  lastAccessedAt: Date;\n  completedAt?: Date;\n}\n\n/**\n * Maps course completion status to API response\n */\nexport const mapCourseCompletionStatusToApiResponse = (\n  status: CourseCompletionStatusData\n): CourseCompletionStatusResponse[\"data\"] => ({\n  courseId: status.courseId,\n  userId: status.userId,\n  totalSections: status.totalSections,\n  completedSections: status.completedSections,\n  completionPercentage: status.completionPercentage,\n  timeSpentSeconds: status.timeSpentSeconds,\n  lastAccessedAt: status.lastAccessedAt.toISOString(),\n  completedAt: status.completedAt?.toISOString(),\n});\n\n/**\n * Calculates course completion status from progress records\n */\nexport const calculateCourseCompletionStatus = (\n  progressRecords: UserProgress[],\n  courseId: string,\n  userId: string,\n  totalSections: number\n): CourseCompletionStatusData => {\n  const courseProgress = progressRecords.filter(\n    p => p.courseId === courseId && p.userId === userId\n  );\n\n  const completedSections = courseProgress.filter(p => p.isCompleted).length;\n  const completionPercentage =\n    totalSections > 0\n      ? Math.round((completedSections / totalSections) * 100)\n      : 0;\n  const timeSpentSeconds = courseProgress.reduce(\n    (sum, p) => sum + p.timeSpentSeconds,\n    0\n  );\n\n  const lastAccessedAt =\n    courseProgress.length > 0\n      ? courseProgress.reduce(\n          (latest, p) =>\n            p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n          courseProgress[0].lastAccessedAt\n        )\n      : new Date();\n\n  const completedAt =\n    completedSections === totalSections && totalSections > 0\n      ? courseProgress.reduce(\n          (latest, p) =>\n            p.completedAt && p.completedAt > latest ? p.completedAt : latest,\n          courseProgress[0].completedAt || new Date(0)\n        )\n      : undefined;\n\n  return {\n    courseId,\n    userId,\n    totalSections,\n    completedSections,\n    completionPercentage,\n    timeSpentSeconds,\n    lastAccessedAt,\n    completedAt:\n      completedAt && completedAt.getTime() > 0 ? completedAt : undefined,\n  };\n};\n\n// =============================================================================\n// PROGRESS TRACKING MAPPERS\n// =============================================================================\n\n/**\n * Progress tracking event data\n */\nexport interface ProgressTrackingEvent {\n  userId: string;\n  courseId: string;\n  sectionId: string;\n  eventType: \"started\" | \"progressed\" | \"completed\" | \"paused\" | \"resumed\";\n  completionPercentage: number;\n  timeSpentSeconds: number;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Maps progress tracking event to user progress update\n */\nexport const mapProgressTrackingEventToProgressUpdate = (\n  event: ProgressTrackingEvent,\n  existingProgress?: UserProgress\n): Partial<UserProgress> => {\n  const now = new Date();\n  const isCompleted =\n    event.eventType === \"completed\" || event.completionPercentage >= 100;\n\n  return {\n    ...existingProgress,\n    userId: event.userId,\n    courseId: event.courseId,\n    sectionId: event.sectionId,\n    isCompleted,\n    completionPercentage: Math.min(event.completionPercentage, 100),\n    timeSpentSeconds: event.timeSpentSeconds,\n    lastAccessedAt: now,\n    completedAt: isCompleted ? now : existingProgress?.completedAt,\n    updatedAt: now,\n  };\n};\n\n// =============================================================================\n// PROGRESS ANALYTICS MAPPERS\n// =============================================================================\n\n/**\n * User progress analytics data\n */\nexport interface UserProgressAnalytics {\n  userId: string;\n  totalCourses: number;\n  completedCourses: number;\n  inProgressCourses: number;\n  totalTimeSpent: number;\n  averageCompletionRate: number;\n  lastActivity?: string;\n  coursesByStatus: {\n    completed: string[];\n    inProgress: string[];\n    notStarted: string[];\n  };\n}\n\n/**\n * Maps user progress records to analytics data\n */\nexport const mapUserProgressToAnalytics = (\n  progressRecords: UserProgress[],\n  userId: string,\n  allCourses: Course[]\n): UserProgressAnalytics => {\n  const userProgress = progressRecords.filter(p => p.userId === userId);\n\n  // Group progress by course\n  const courseProgressMap = new Map<string, UserProgress[]>();\n  userProgress.forEach(p => {\n    const existing = courseProgressMap.get(p.courseId) || [];\n    existing.push(p);\n    courseProgressMap.set(p.courseId, existing);\n  });\n\n  const totalCourses = allCourses.length;\n  let completedCourses = 0;\n  let inProgressCourses = 0;\n  const totalTimeSpent = userProgress.reduce(\n    (sum, p) => sum + p.timeSpentSeconds,\n    0\n  );\n\n  const coursesByStatus = {\n    completed: [] as string[],\n    inProgress: [] as string[],\n    notStarted: [] as string[],\n  };\n\n  // Analyze each course\n  allCourses.forEach(course => {\n    const courseProgress = courseProgressMap.get(course.id) || [];\n    const completedSections = courseProgress.filter(p => p.isCompleted).length;\n    const totalSections = courseProgress.length;\n\n    if (totalSections === 0) {\n      coursesByStatus.notStarted.push(course.id);\n    } else if (completedSections === totalSections && totalSections > 0) {\n      completedCourses++;\n      coursesByStatus.completed.push(course.id);\n    } else {\n      inProgressCourses++;\n      coursesByStatus.inProgress.push(course.id);\n    }\n  });\n\n  const averageCompletionRate =\n    totalCourses > 0 ? (completedCourses / totalCourses) * 100 : 0;\n\n  const lastActivity =\n    userProgress.length > 0\n      ? userProgress\n          .reduce(\n            (latest, p) =>\n              p.lastAccessedAt > latest ? p.lastAccessedAt : latest,\n            userProgress[0].lastAccessedAt\n          )\n          .toISOString()\n      : undefined;\n\n  return {\n    userId,\n    totalCourses,\n    completedCourses,\n    inProgressCourses,\n    totalTimeSpent,\n    averageCompletionRate,\n    lastActivity,\n    coursesByStatus,\n  };\n};\n\n// =============================================================================\n// PROGRESS FILTERING MAPPERS\n// =============================================================================\n\n/**\n * User progress filtering criteria\n */\nexport interface UserProgressFilterCriteria {\n  userId?: string;\n  courseId?: string;\n  sectionId?: string;\n  isCompleted?: boolean;\n  completionPercentageMin?: number;\n  completionPercentageMax?: number;\n  dateFrom?: Date;\n  dateTo?: Date;\n}\n\n/**\n * Maps filtering criteria to database query filters\n */\nexport const mapUserProgressFilterCriteriaToDbFilters = (\n  criteria: UserProgressFilterCriteria\n): any => {\n  const where: any = {};\n\n  if (criteria.userId) {\n    where.userId = criteria.userId;\n  }\n\n  if (criteria.courseId) {\n    where.courseId = criteria.courseId;\n  }\n\n  if (criteria.sectionId) {\n    where.sectionId = criteria.sectionId;\n  }\n\n  if (criteria.isCompleted !== undefined) {\n    where.isCompleted = criteria.isCompleted;\n  }\n\n  if (\n    criteria.completionPercentageMin !== undefined ||\n    criteria.completionPercentageMax !== undefined\n  ) {\n    where.completionPercentage = {};\n    if (criteria.completionPercentageMin !== undefined) {\n      where.completionPercentage.gte = criteria.completionPercentageMin;\n    }\n    if (criteria.completionPercentageMax !== undefined) {\n      where.completionPercentage.lte = criteria.completionPercentageMax;\n    }\n  }\n\n  if (criteria.dateFrom || criteria.dateTo) {\n    where.lastAccessedAt = {};\n    if (criteria.dateFrom) {\n      where.lastAccessedAt.gte = criteria.dateFrom;\n    }\n    if (criteria.dateTo) {\n      where.lastAccessedAt.lte = criteria.dateTo;\n    }\n  }\n\n  return where;\n};\n\n// =============================================================================\n// PROGRESS ACCESS VALIDATION MAPPERS\n// =============================================================================\n\n/**\n * User progress access validation result\n */\nexport interface UserProgressAccessResult {\n  hasAccess: boolean;\n  progress?: UserProgressSchema;\n  reason?: string;\n  permissions?: {\n    canView: boolean;\n    canEdit: boolean;\n    canDelete: boolean;\n  };\n}\n\n/**\n * Validates user progress access based on user role and ownership\n */\nexport const validateUserProgressAccess = (\n  progress: UserProgress,\n  userId: string,\n  userRole: string\n): UserProgressAccessResult => {\n  // Users can always access their own progress\n  if (progress.userId === userId) {\n    return {\n      hasAccess: true,\n      progress: mapUserProgressToApiResponse(progress),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: false,\n      },\n    };\n  }\n\n  // Safety admins can access all progress\n  if (userRole === \"safety_admin\") {\n    return {\n      hasAccess: true,\n      progress: mapUserProgressToApiResponse(progress),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n      },\n    };\n  }\n\n  // Plant managers can access progress in their plant\n  if (userRole === \"plant_manager\") {\n    return {\n      hasAccess: true,\n      progress: mapUserProgressToApiResponse(progress),\n      permissions: {\n        canView: true,\n        canEdit: true,\n        canDelete: true,\n      },\n    };\n  }\n\n  // HR admins can view progress in their plant\n  if (userRole === \"hr_admin\") {\n    return {\n      hasAccess: true,\n      progress: mapUserProgressToApiResponse(progress),\n      permissions: {\n        canView: true,\n        canEdit: false,\n        canDelete: false,\n      },\n    };\n  }\n\n  return {\n    hasAccess: false,\n    reason: \"User does not have access to this progress record\",\n  };\n};\n\n// =============================================================================\n// TYPE EXPORTS\n// =============================================================================\n\nexport type {\n  CourseCompletionStatusData,\n  ProgressTrackingEvent,\n  UserProgressAnalytics,\n  UserProgressFilterCriteria,\n  UserProgressAccessResult,\n};\n"],"names":[],"mappings":"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"}